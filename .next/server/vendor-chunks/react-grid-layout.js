/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-grid-layout";
exports.ids = ["vendor-chunks/react-grid-layout"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-grid-layout/build/GridItem.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-grid-layout/build/GridItem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\nvar _reactResizable = __webpack_require__(/*! react-resizable */ \"(ssr)/./node_modules/react-resizable/index.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _ReactGridLayoutPropTypes = __webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight,\n            containerPadding\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top - containerPadding[1], 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left - containerPadding[0], 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports[\"default\"] = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvR3JpZEl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNuQyx3Q0FBd0MsbUJBQU8sQ0FBQyw0REFBWTtBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsc0VBQWlCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3BFLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHVDQUF1Qyx1Q0FBdUM7QUFDOUUsNENBQTRDLDJCQUEyQixrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FBQy9OLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLCtEQUErRCxzQ0FBc0MsMEJBQTBCLCtDQUErQyx5Q0FBeUMsdUVBQXVFO0FBQ25VLG1CQUFtQiw2Q0FBNkMsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQixtQkFBbUIsaUJBQWlCLHdCQUF3QjtBQUM1RCxtQkFBbUIseUJBQXlCLGtDQUFrQztBQUM5RSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxlQUFlLDBEQUEwRDtBQUN6RSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQjtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL0dyaWRJdGVtLmpzP2MzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdERyYWdnYWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1kcmFnZ2FibGVcIik7XG52YXIgX3JlYWN0UmVzaXphYmxlID0gcmVxdWlyZShcInJlYWN0LXJlc2l6YWJsZVwiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfY2FsY3VsYXRlVXRpbHMgPSByZXF1aXJlKFwiLi9jYWxjdWxhdGVVdGlsc1wiKTtcbnZhciBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7IEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50LCBOb2RlIGFzIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgUmVhY3REcmFnZ2FibGVDYWxsYmFja0RhdGEsXG4gIEdyaWREcmFnRXZlbnQsXG4gIEdyaWRSZXNpemVFdmVudCxcbiAgRHJvcHBpbmdQb3NpdGlvbixcbiAgUG9zaXRpb24sXG4gIFJlc2l6ZUhhbmRsZUF4aXNcbn0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFBvc2l0aW9uUGFyYW1zIH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFJlc2l6ZUhhbmRsZSwgUmVhY3RSZWYgfSBmcm9tIFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFBhcnRpYWxQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9OyovXG4vKjo6IHR5cGUgR3JpZEl0ZW1DYWxsYmFjazxEYXRhOiBHcmlkRHJhZ0V2ZW50IHwgR3JpZFJlc2l6ZUV2ZW50PiA9IChcbiAgaTogc3RyaW5nLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgRGF0YVxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgUmVzaXplQ2FsbGJhY2tEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgc2l6ZTogUG9zaXRpb24sXG4gIGhhbmRsZTogUmVzaXplSGFuZGxlQXhpc1xufTsqL1xuLyo6OiB0eXBlIEdyaWRJdGVtUmVzaXplQ2FsbGJhY2sgPSAoXG4gIGU6IEV2ZW50LFxuICBkYXRhOiBSZXNpemVDYWxsYmFja0RhdGEsXG4gIHBvc2l0aW9uOiBQb3NpdGlvblxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgU3RhdGUgPSB7XG4gIHJlc2l6aW5nOiA/eyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LFxuICBkcmFnZ2luZzogP3sgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9LFxuICBjbGFzc05hbWU6IHN0cmluZ1xufTsqL1xuLyo6OiB0eXBlIFByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIGNvbHM6IG51bWJlcixcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICBjb250YWluZXJQYWRkaW5nOiBbbnVtYmVyLCBudW1iZXJdLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgbWF4Um93czogbnVtYmVyLFxuICBpc0RyYWdnYWJsZTogYm9vbGVhbixcbiAgaXNSZXNpemFibGU6IGJvb2xlYW4sXG4gIGlzQm91bmRlZDogYm9vbGVhbixcbiAgc3RhdGljPzogYm9vbGVhbixcbiAgdXNlQ1NTVHJhbnNmb3Jtcz86IGJvb2xlYW4sXG4gIHVzZVBlcmNlbnRhZ2VzPzogYm9vbGVhbixcbiAgdHJhbnNmb3JtU2NhbGU6IG51bWJlcixcbiAgZHJvcHBpbmdQb3NpdGlvbj86IERyb3BwaW5nUG9zaXRpb24sXG5cbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAvLyBEcmFnZ2FiaWxpdHlcbiAgY2FuY2VsOiBzdHJpbmcsXG4gIGhhbmRsZTogc3RyaW5nLFxuXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcblxuICBtaW5XOiBudW1iZXIsXG4gIG1heFc6IG51bWJlcixcbiAgbWluSDogbnVtYmVyLFxuICBtYXhIOiBudW1iZXIsXG4gIGk6IHN0cmluZyxcblxuICByZXNpemVIYW5kbGVzPzogUmVzaXplSGFuZGxlQXhpc1tdLFxuICByZXNpemVIYW5kbGU/OiBSZXNpemVIYW5kbGUsXG5cbiAgb25EcmFnPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25EcmFnU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWREcmFnRXZlbnQ+LFxuICBvbkRyYWdTdG9wPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25SZXNpemU/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RvcD86IEdyaWRJdGVtQ2FsbGJhY2s8R3JpZFJlc2l6ZUV2ZW50PlxufTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBoYW5kbGU6IHN0cmluZyxcbiAgbWluSDogbnVtYmVyLFxuICBtaW5XOiBudW1iZXIsXG4gIG1heEg6IG51bWJlcixcbiAgbWF4VzogbnVtYmVyLFxuICB0cmFuc2Zvcm1TY2FsZTogbnVtYmVyXG59OyovXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgaXRlbSB3aXRoaW4gYSBSZWFjdEdyaWRMYXlvdXQuXG4gKi9cbmNsYXNzIEdyaWRJdGVtIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IC8qOjogPFByb3BzLCBTdGF0ZT4qL3tcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICByZXNpemluZzogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgY2xhc3NOYW1lOiBcIlwiXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZWxlbWVudFJlZlwiLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlUmVmKCkpO1xuICAgIC8qKlxuICAgICAqIG9uRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgX3JlZikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIW9uRHJhZ1N0YXJ0KSByZXR1cm47XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcblxuICAgICAgLy8gVE9ETzogdGhpcyB3b250IHdvcmsgb24gbmVzdGVkIHBhcmVudHNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0UGFyZW50XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGlmICghb2Zmc2V0UGFyZW50KSByZXR1cm47XG4gICAgICBjb25zdCBwYXJlbnRSZWN0ID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjTGVmdCA9IGNsaWVudFJlY3QubGVmdCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcExlZnQgPSBwYXJlbnRSZWN0LmxlZnQgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgIGNvbnN0IGNUb3AgPSBjbGllbnRSZWN0LnRvcCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcFRvcCA9IHBhcmVudFJlY3QudG9wIC8gdHJhbnNmb3JtU2NhbGU7XG4gICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gY0xlZnQgLSBwTGVmdCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgbmV3UG9zaXRpb24udG9wID0gY1RvcCAtIHBUb3AgKyBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIG5ld1Bvc2l0aW9uLnRvcCwgbmV3UG9zaXRpb24ubGVmdCwgdGhpcy5wcm9wcy53LCB0aGlzLnByb3BzLmgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgdGhpcy5wcm9wcy5pLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWcgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUsIGRlbHRhIGFuZCBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGRvbnRGbHVzaCAgICBpZiB0cnVlLCB3aWxsIG5vdCBjYWxsIGZsdXNoU3luY1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoZSwgX3JlZjIsIGRvbnRGbHVzaCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYLFxuICAgICAgICBkZWx0YVlcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25EcmFnIGNhbGxlZCBiZWZvcmUgb25EcmFnU3RhcnQuXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHRvcCA9IHRoaXMuc3RhdGUuZHJhZ2dpbmcudG9wICsgZGVsdGFZO1xuICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLmRyYWdnaW5nLmxlZnQgKyBkZWx0YVg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzQm91bmRlZCxcbiAgICAgICAgaSxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgY29udGFpbmVyV2lkdGhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgcG9zaXRpb25QYXJhbXMgPSB0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCk7XG5cbiAgICAgIC8vIEJvdW5kYXJ5IGNhbGN1bGF0aW9uczsga2VlcHMgaXRlbXMgd2l0aGluIHRoZSBncmlkXG4gICAgICBpZiAoaXNCb3VuZGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnRcbiAgICAgICAgfSA9IG5vZGU7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nXG4gICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgY29uc3QgYm90dG9tQm91bmRhcnkgPSBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IC0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1XSFB4KShoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gICAgICAgICAgdG9wID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkodG9wIC0gY29udGFpbmVyUGFkZGluZ1sxXSwgMCwgYm90dG9tQm91bmRhcnkpO1xuICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZENvbFdpZHRoKShwb3NpdGlvblBhcmFtcyk7XG4gICAgICAgICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IGNvbnRhaW5lcldpZHRoIC0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1XSFB4KSh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICAgICAgICBsZWZ0ID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkobGVmdCAtIGNvbnRhaW5lclBhZGRpbmdbMF0sIDAsIHJpZ2h0Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcblxuICAgICAgLy8gZG9udEZsdXNoIGlzIHNldCBpZiB3ZSdyZSBjYWxsaW5nIGZyb20gaW5zaWRlXG4gICAgICBpZiAoZG9udEZsdXNoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfcmVhY3REb20uZmx1c2hTeW5jKSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcmFnZ2luZzogbmV3UG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKShwb3NpdGlvblBhcmFtcywgdG9wLCBsZWZ0LCB3LCBoKTtcbiAgICAgIHJldHVybiBvbkRyYWcuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWdTdG9wIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdG9wXCIsIChlLCBfcmVmMykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdTdG9wXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnU3RvcCkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRHJhZ0VuZCBjYWxsZWQgYmVmb3JlIG9uRHJhZ1N0YXJ0LlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgaVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcFxuICAgICAgfSA9IHRoaXMuc3RhdGUuZHJhZ2dpbmc7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogbnVsbFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCB0b3AsIGxlZnQsIHcsIGgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0b3AuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvblJlc2l6ZVN0b3AgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUgYW5kIHNpemUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0b3BcIiwgKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24pID0+IHRoaXMub25SZXNpemVIYW5kbGVyKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24sIFwib25SZXNpemVTdG9wXCIpKTtcbiAgICAvLyBvblJlc2l6ZVN0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0YXJ0XCIsIChlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uKSA9PiB0aGlzLm9uUmVzaXplSGFuZGxlcihlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uLCBcIm9uUmVzaXplU3RhcnRcIikpO1xuICAgIC8vIG9uUmVzaXplIGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVwiLCAoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbikgPT4gdGhpcy5vblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbiwgXCJvblJlc2l6ZVwiKSk7XG4gIH1cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcyAvKjogUHJvcHMqLywgbmV4dFN0YXRlIC8qOiBTdGF0ZSovKSAvKjogYm9vbGVhbiove1xuICAgIC8vIFdlIGNhbid0IGRlZXBseSBjb21wYXJlIGNoaWxkcmVuLiBJZiB0aGUgZGV2ZWxvcGVyIG1lbW9pemVzIHRoZW0sIHdlIGNhblxuICAgIC8vIHVzZSB0aGlzIG9wdGltaXphdGlvbi5cbiAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5kcm9wcGluZ1Bvc2l0aW9uICE9PSBuZXh0UHJvcHMuZHJvcHBpbmdQb3NpdGlvbikgcmV0dXJuIHRydWU7XG4gICAgLy8gVE9ETyBtZW1vaXplIHRoZXNlIGNhbGN1bGF0aW9ucyBzbyB0aGV5IGRvbid0IHRha2Ugc28gbG9uZz9cbiAgICBjb25zdCBvbGRQb3NpdGlvbiA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXModGhpcy5wcm9wcyksIHRoaXMucHJvcHMueCwgdGhpcy5wcm9wcy55LCB0aGlzLnByb3BzLncsIHRoaXMucHJvcHMuaCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKG5leHRQcm9wcyksIG5leHRQcm9wcy54LCBuZXh0UHJvcHMueSwgbmV4dFByb3BzLncsIG5leHRQcm9wcy5oLCBuZXh0U3RhdGUpO1xuICAgIHJldHVybiAhKDAsIF91dGlscy5mYXN0UG9zaXRpb25FcXVhbCkob2xkUG9zaXRpb24sIG5ld1Bvc2l0aW9uKSB8fCB0aGlzLnByb3BzLnVzZUNTU1RyYW5zZm9ybXMgIT09IG5leHRQcm9wcy51c2VDU1NUcmFuc2Zvcm1zO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbSh7fSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyAvKjogUHJvcHMqLykge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMpO1xuICB9XG5cbiAgLy8gV2hlbiBhIGRyb3BwaW5nUG9zaXRpb24gaXMgcHJlc2VudCwgdGhpcyBtZWFucyB3ZSBzaG91bGQgZmlyZSBhIG1vdmUgZXZlbnQsIGFzIGlmIHdlIGhhZCBtb3ZlZFxuICAvLyB0aGlzIGVsZW1lbnQgYnkgYHgsIHlgIHBpeGVscy5cbiAgbW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFkcm9wcGluZ1Bvc2l0aW9uKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIC8vIENhbid0IGZpbmQgRE9NIG5vZGUgKGFyZSB3ZSB1bm1vdW50ZWQ/KVxuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZEcm9wcGluZ1Bvc2l0aW9uID0gcHJldlByb3BzLmRyb3BwaW5nUG9zaXRpb24gfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ2dpbmdcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzaG91bGREcmFnID0gZHJhZ2dpbmcgJiYgZHJvcHBpbmdQb3NpdGlvbi5sZWZ0ICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi5sZWZ0IHx8IGRyb3BwaW5nUG9zaXRpb24udG9wICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi50b3A7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgdGhpcy5vbkRyYWdTdGFydChkcm9wcGluZ1Bvc2l0aW9uLmUsIHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYOiBkcm9wcGluZ1Bvc2l0aW9uLmxlZnQsXG4gICAgICAgIGRlbHRhWTogZHJvcHBpbmdQb3NpdGlvbi50b3BcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkRHJhZykge1xuICAgICAgY29uc3QgZGVsdGFYID0gZHJvcHBpbmdQb3NpdGlvbi5sZWZ0IC0gZHJhZ2dpbmcubGVmdDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IGRyb3BwaW5nUG9zaXRpb24udG9wIC0gZHJhZ2dpbmcudG9wO1xuICAgICAgdGhpcy5vbkRyYWcoZHJvcHBpbmdQb3NpdGlvbi5lLCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9LCB0cnVlIC8vIGRvbnRGTHVzaDogYXZvaWQgZmx1c2hTeW5jIHRvIHRlbXBlciB3YXJuaW5nc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb3NpdGlvblBhcmFtcygpIC8qOiBQb3NpdGlvblBhcmFtcyove1xuICAgIGxldCBwcm9wcyAvKjogUHJvcHMqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5wcm9wcztcbiAgICByZXR1cm4ge1xuICAgICAgY29sczogcHJvcHMuY29scyxcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IHByb3BzLmNvbnRhaW5lclBhZGRpbmcsXG4gICAgICBjb250YWluZXJXaWR0aDogcHJvcHMuY29udGFpbmVyV2lkdGgsXG4gICAgICBtYXJnaW46IHByb3BzLm1hcmdpbixcbiAgICAgIG1heFJvd3M6IHByb3BzLm1heFJvd3MsXG4gICAgICByb3dIZWlnaHQ6IHByb3BzLnJvd0hlaWdodFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB3aGVyZSB3ZSBzZXQgdGhlIGdyaWQgaXRlbSdzIGFic29sdXRlIHBsYWNlbWVudC4gSXQgZ2V0cyBhIGxpdHRsZSB0cmlja3kgYmVjYXVzZSB3ZSB3YW50IHRvIGRvIGl0XG4gICAqIHdlbGwgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nLCBhbmQgdGhlIG9ubHkgd2F5IHRvIGRvIHRoYXQgcHJvcGVybHkgaXMgdG8gdXNlIHBlcmNlbnRhZ2Ugd2lkdGgvbGVmdCBiZWNhdXNlXG4gICAqIHdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IHRoZSBicm93c2VyIHZpZXdwb3J0IGlzLlxuICAgKiBVbmZvcnR1bmF0ZWx5LCBDU1MgVHJhbnNmb3Jtcywgd2hpY2ggYXJlIGdyZWF0IGZvciBwZXJmb3JtYW5jZSwgYnJlYWsgaW4gdGhpcyBpbnN0YW5jZSBiZWNhdXNlIGEgcGVyY2VudGFnZVxuICAgKiBsZWZ0IGlzIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGl0c2VsZiwgbm90IGl0cyBjb250YWluZXIhIFNvIHdlIGNhbm5vdCB1c2UgdGhlbSBvbiB0aGUgc2VydmVyIHJlbmRlcmluZyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvcyBQb3NpdGlvbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgIFN0eWxlIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZVN0eWxlKHBvcyAvKjogUG9zaXRpb24qLykgLyo6IHsgW2tleTogc3RyaW5nXTogP3N0cmluZyB9Ki97XG4gICAgY29uc3Qge1xuICAgICAgdXNlUGVyY2VudGFnZXMsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgc3R5bGU7XG4gICAgLy8gQ1NTIFRyYW5zZm9ybXMgc3VwcG9ydCAoZGVmYXVsdClcbiAgICBpZiAodXNlQ1NTVHJhbnNmb3Jtcykge1xuICAgICAgc3R5bGUgPSAoMCwgX3V0aWxzLnNldFRyYW5zZm9ybSkocG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9wLGxlZnQgKHNsb3cpXG4gICAgICBzdHlsZSA9ICgwLCBfdXRpbHMuc2V0VG9wTGVmdCkocG9zKTtcblxuICAgICAgLy8gVGhpcyBpcyB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgaWYgKHVzZVBlcmNlbnRhZ2VzKSB7XG4gICAgICAgIHN0eWxlLmxlZnQgPSAoMCwgX3V0aWxzLnBlcmMpKHBvcy5sZWZ0IC8gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICgwLCBfdXRpbHMucGVyYykocG9zLndpZHRoIC8gY29udGFpbmVyV2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogTWl4IGEgRHJhZ2dhYmxlIGluc3RhbmNlIGludG8gYSBjaGlsZC5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICAgQ2hpbGQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgICAgQ2hpbGQgd3JhcHBlZCBpbiBEcmFnZ2FibGUuXG4gICAqL1xuICBtaXhpbkRyYWdnYWJsZShjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLywgaXNEcmFnZ2FibGUgLyo6IGJvb2xlYW4qLykgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdERyYWdnYWJsZS5EcmFnZ2FibGVDb3JlLCB7XG4gICAgICBkaXNhYmxlZDogIWlzRHJhZ2dhYmxlLFxuICAgICAgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICBvblN0b3A6IHRoaXMub25EcmFnU3RvcCxcbiAgICAgIGhhbmRsZTogdGhpcy5wcm9wcy5oYW5kbGUsXG4gICAgICBjYW5jZWw6IFwiLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGVcIiArICh0aGlzLnByb3BzLmNhbmNlbCA/IFwiLFwiICsgdGhpcy5wcm9wcy5jYW5jZWwgOiBcIlwiKSxcbiAgICAgIHNjYWxlOiB0aGlzLnByb3BzLnRyYW5zZm9ybVNjYWxlLFxuICAgICAgbm9kZVJlZjogdGhpcy5lbGVtZW50UmVmXG4gICAgfSwgY2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gc2V0dXAgY2FsbGJhY2sgaGFuZGxlciBkZWZpbml0aW9ucyBmb3JcbiAgICogc2ltaWxhcmlseSBzdHJ1Y3R1cmVkIHJlc2l6ZSBldmVudHMuXG4gICAqL1xuICBjdXJyeVJlc2l6ZUhhbmRsZXIocG9zaXRpb24gLyo6IFBvc2l0aW9uKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8pIC8qOiBGdW5jdGlvbiove1xuICAgIHJldHVybiAoZSAvKjogRXZlbnQqLywgZGF0YSAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi8pID0+IC8qOiBGdW5jdGlvbiovaGFuZGxlcihlLCBkYXRhLCBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogTWl4IGEgUmVzaXphYmxlIGluc3RhbmNlIGludG8gYSBjaGlsZC5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICAgQ2hpbGQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb3NpdGlvbiAgUG9zaXRpb24gb2JqZWN0IChwaXhlbCB2YWx1ZXMpXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICAgICAgIENoaWxkIHdyYXBwZWQgaW4gUmVzaXphYmxlLlxuICAgKi9cbiAgbWl4aW5SZXNpemFibGUoY2hpbGQgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki8sIHBvc2l0aW9uIC8qOiBQb3NpdGlvbiovLCBpc1Jlc2l6YWJsZSAvKjogYm9vbGVhbiovKSAvKjogUmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBjb25zdCB7XG4gICAgICBjb2xzLFxuICAgICAgbWluVyxcbiAgICAgIG1pbkgsXG4gICAgICBtYXhXLFxuICAgICAgbWF4SCxcbiAgICAgIHRyYW5zZm9ybVNjYWxlLFxuICAgICAgcmVzaXplSGFuZGxlcyxcbiAgICAgIHJlc2l6ZUhhbmRsZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBvc2l0aW9uUGFyYW1zID0gdGhpcy5nZXRQb3NpdGlvblBhcmFtcygpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWF4IHBvc3NpYmxlIHdpZHRoIC0gZG9lc24ndCBnbyB0byBpbmZpbml0eSBiZWNhdXNlIG9mIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG4gICAgY29uc3QgbWF4V2lkdGggPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKShwb3NpdGlvblBhcmFtcywgMCwgMCwgY29scywgMCkud2lkdGg7XG5cbiAgICAvLyBDYWxjdWxhdGUgbWluL21heCBjb25zdHJhaW50cyB1c2luZyBvdXIgbWluICYgbWF4ZXNcbiAgICBjb25zdCBtaW5zID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikocG9zaXRpb25QYXJhbXMsIDAsIDAsIG1pblcsIG1pbkgpO1xuICAgIGNvbnN0IG1heGVzID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikocG9zaXRpb25QYXJhbXMsIDAsIDAsIG1heFcsIG1heEgpO1xuICAgIGNvbnN0IG1pbkNvbnN0cmFpbnRzID0gW21pbnMud2lkdGgsIG1pbnMuaGVpZ2h0XTtcbiAgICBjb25zdCBtYXhDb25zdHJhaW50cyA9IFtNYXRoLm1pbihtYXhlcy53aWR0aCwgbWF4V2lkdGgpLCBNYXRoLm1pbihtYXhlcy5oZWlnaHQsIEluZmluaXR5KV07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdFJlc2l6YWJsZS5SZXNpemFibGVcbiAgICAvLyBUaGVzZSBhcmUgb3B0cyBmb3IgdGhlIHJlc2l6ZSBoYW5kbGUgaXRzZWxmXG4gICAgLCB7XG4gICAgICBkcmFnZ2FibGVPcHRzOiB7XG4gICAgICAgIGRpc2FibGVkOiAhaXNSZXNpemFibGVcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IGlzUmVzaXphYmxlID8gdW5kZWZpbmVkIDogXCJyZWFjdC1yZXNpemFibGUtaGlkZVwiLFxuICAgICAgd2lkdGg6IHBvc2l0aW9uLndpZHRoLFxuICAgICAgaGVpZ2h0OiBwb3NpdGlvbi5oZWlnaHQsXG4gICAgICBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsXG4gICAgICBtYXhDb25zdHJhaW50czogbWF4Q29uc3RyYWludHMsXG4gICAgICBvblJlc2l6ZVN0b3A6IHRoaXMuY3VycnlSZXNpemVIYW5kbGVyKHBvc2l0aW9uLCB0aGlzLm9uUmVzaXplU3RvcCksXG4gICAgICBvblJlc2l6ZVN0YXJ0OiB0aGlzLmN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiwgdGhpcy5vblJlc2l6ZVN0YXJ0KSxcbiAgICAgIG9uUmVzaXplOiB0aGlzLmN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiwgdGhpcy5vblJlc2l6ZSksXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzLFxuICAgICAgaGFuZGxlOiByZXNpemVIYW5kbGVcbiAgICB9LCBjaGlsZCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIHJlc2l6ZSBldmVudHMgdG8gcHJvdmlkZSBtb3JlIHVzZWZ1bCBkYXRhLlxuICAgKi9cbiAgb25SZXNpemVIYW5kbGVyKGUgLyo6IEV2ZW50Ki8sIF9yZWY0IC8qOjogKi8sXG4gIC8vICdzaXplJyBpcyB1cGRhdGVkIHBvc2l0aW9uXG4gIHBvc2l0aW9uIC8qOiBQb3NpdGlvbiovLFxuICAvLyBleGlzdGluZyBwb3NpdGlvblxuICBoYW5kbGVyTmFtZSAvKjogc3RyaW5nKi8pIC8qOiB2b2lkKi97XG4gICAgbGV0IHtcbiAgICAgIG5vZGUsXG4gICAgICBzaXplLFxuICAgICAgaGFuZGxlXG4gICAgfSAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi8gPSBfcmVmNCAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi87XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucHJvcHNbaGFuZGxlck5hbWVdO1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIG1heEgsXG4gICAgICBtaW5ILFxuICAgICAgY29udGFpbmVyV2lkdGhcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBtaW5XLFxuICAgICAgbWF4V1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2xhbXBpbmcgb2YgZGltZW5zaW9ucyBiYXNlZCBvbiByZXNpemUgZGlyZWN0aW9uXG4gICAgbGV0IHVwZGF0ZWRTaXplID0gc2l6ZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgdXBkYXRlZFNpemUgPSAoMCwgX3V0aWxzLnJlc2l6ZUl0ZW1JbkRpcmVjdGlvbikoaGFuZGxlLCBwb3NpdGlvbiwgc2l6ZSwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgKDAsIF9yZWFjdERvbS5mbHVzaFN5bmMpKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcmVzaXppbmc6IGhhbmRsZXJOYW1lID09PSBcIm9uUmVzaXplU3RvcFwiID8gbnVsbCA6IHVwZGF0ZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IG5ldyBYWSBiYXNlZCBvbiBwaXhlbCBzaXplXG4gICAgbGV0IHtcbiAgICAgIHcsXG4gICAgICBoXG4gICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1dIKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIHVwZGF0ZWRTaXplLndpZHRoLCB1cGRhdGVkU2l6ZS5oZWlnaHQsIHgsIHksIGhhbmRsZSk7XG5cbiAgICAvLyBNaW4vbWF4IGNhcHBpbmcuXG4gICAgLy8gbWluVyBzaG91bGQgYmUgYXQgbGVhc3QgMSAoVE9ETyBwcm9wVHlwZXMgdmFsaWRhdGlvbj8pXG4gICAgdyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2xhbXApKHcsIE1hdGgubWF4KG1pblcsIDEpLCBtYXhXKTtcbiAgICBoID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkoaCwgbWluSCwgbWF4SCk7XG4gICAgaGFuZGxlci5jYWxsKHRoaXMsIGksIHcsIGgsIHtcbiAgICAgIGUsXG4gICAgICBub2RlLFxuICAgICAgc2l6ZTogdXBkYXRlZFNpemUsXG4gICAgICBoYW5kbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3ROb2RlKi97XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIGlzRHJhZ2dhYmxlLFxuICAgICAgaXNSZXNpemFibGUsXG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uLFxuICAgICAgdXNlQ1NTVHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBvcyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXMoKSwgeCwgeSwgdywgaCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBjaGlsZCBlbGVtZW50LiBXZSBjbG9uZSB0aGUgZXhpc3RpbmcgZWxlbWVudCBidXQgbW9kaWZ5IGl0cyBjbGFzc05hbWUgYW5kIHN0eWxlLlxuICAgIGxldCBuZXdDaGlsZCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHJlZjogdGhpcy5lbGVtZW50UmVmLFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3guZGVmYXVsdCkoXCJyZWFjdC1ncmlkLWl0ZW1cIiwgY2hpbGQucHJvcHMuY2xhc3NOYW1lLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwge1xuICAgICAgICBzdGF0aWM6IHRoaXMucHJvcHMuc3RhdGljLFxuICAgICAgICByZXNpemluZzogQm9vbGVhbih0aGlzLnN0YXRlLnJlc2l6aW5nKSxcbiAgICAgICAgXCJyZWFjdC1kcmFnZ2FibGVcIjogaXNEcmFnZ2FibGUsXG4gICAgICAgIFwicmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nXCI6IEJvb2xlYW4odGhpcy5zdGF0ZS5kcmFnZ2luZyksXG4gICAgICAgIGRyb3BwaW5nOiBCb29sZWFuKGRyb3BwaW5nUG9zaXRpb24pLFxuICAgICAgICBjc3NUcmFuc2Zvcm1zOiB1c2VDU1NUcmFuc2Zvcm1zXG4gICAgICB9KSxcbiAgICAgIC8vIFdlIGNhbiBzZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIGNoaWxkLCBidXQgdW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBzZXQgdGhlIHBvc2l0aW9uLlxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4uY2hpbGQucHJvcHMuc3R5bGUsXG4gICAgICAgIC4uLnRoaXMuY3JlYXRlU3R5bGUocG9zKVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVzaXphYmxlIHN1cHBvcnQuIFRoaXMgaXMgdXN1YWxseSBvbiBidXQgdGhlIHVzZXIgY2FuIHRvZ2dsZSBpdCBvZmYuXG4gICAgbmV3Q2hpbGQgPSB0aGlzLm1peGluUmVzaXphYmxlKG5ld0NoaWxkLCBwb3MsIGlzUmVzaXphYmxlKTtcblxuICAgIC8vIERyYWdnYWJsZSBzdXBwb3J0LiBUaGlzIGlzIGFsd2F5cyBvbiwgZXhjZXB0IGZvciB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICBuZXdDaGlsZCA9IHRoaXMubWl4aW5EcmFnZ2FibGUobmV3Q2hpbGQsIGlzRHJhZ2dhYmxlKTtcbiAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdyaWRJdGVtO1xuX2RlZmluZVByb3BlcnR5KEdyaWRJdGVtLCBcInByb3BUeXBlc1wiLCB7XG4gIC8vIENoaWxkcmVuIG11c3QgYmUgb25seSBhIHNpbmdsZSBlbGVtZW50XG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQuZWxlbWVudCxcbiAgLy8gR2VuZXJhbCBncmlkIGF0dHJpYnV0ZXNcbiAgY29sczogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBjb250YWluZXJXaWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICByb3dIZWlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbWFyZ2luOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXkuaXNSZXF1aXJlZCxcbiAgbWF4Um93czogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBjb250YWluZXJQYWRkaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXkuaXNSZXF1aXJlZCxcbiAgLy8gVGhlc2UgYXJlIGFsbCBpbiBncmlkIHVuaXRzXG4gIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICB3OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLy8gQWxsIG9wdGlvbmFsXG4gIG1pblc6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1pbldpZHRoIG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlID4gcHJvcHMudyB8fCB2YWx1ZSA+IHByb3BzLm1heFcpIHJldHVybiBuZXcgRXJyb3IoXCJtaW5XaWR0aCBsYXJnZXIgdGhhbiBpdGVtIHdpZHRoL21heFdpZHRoXCIpO1xuICB9LFxuICBtYXhXOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhXaWR0aCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA8IHByb3BzLncgfHwgdmFsdWUgPCBwcm9wcy5taW5XKSByZXR1cm4gbmV3IEVycm9yKFwibWF4V2lkdGggc21hbGxlciB0aGFuIGl0ZW0gd2lkdGgvbWluV2lkdGhcIik7XG4gIH0sXG4gIG1pbkg6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1pbkhlaWdodCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA+IHByb3BzLmggfHwgdmFsdWUgPiBwcm9wcy5tYXhIKSByZXR1cm4gbmV3IEVycm9yKFwibWluSGVpZ2h0IGxhcmdlciB0aGFuIGl0ZW0gaGVpZ2h0L21heEhlaWdodFwiKTtcbiAgfSxcbiAgbWF4SDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSByZXR1cm4gbmV3IEVycm9yKFwibWF4SGVpZ2h0IG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlIDwgcHJvcHMuaCB8fCB2YWx1ZSA8IHByb3BzLm1pbkgpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhIZWlnaHQgc21hbGxlciB0aGFuIGl0ZW0gaGVpZ2h0L21pbkhlaWdodFwiKTtcbiAgfSxcbiAgLy8gSUQgaXMgbmljZSB0byBoYXZlIGZvciBjYWxsYmFja3NcbiAgaTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAvLyBSZXNpemUgaGFuZGxlIG9wdGlvbnNcbiAgcmVzaXplSGFuZGxlczogX1JlYWN0R3JpZExheW91dFByb3BUeXBlcy5yZXNpemVIYW5kbGVBeGVzVHlwZSxcbiAgcmVzaXplSGFuZGxlOiBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLnJlc2l6ZUhhbmRsZVR5cGUsXG4gIC8vIEZ1bmN0aW9uc1xuICBvbkRyYWdTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25EcmFnU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvblJlc2l6ZVN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25SZXNpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBGbGFnc1xuICBpc0RyYWdnYWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgaXNSZXNpemFibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIGlzQm91bmRlZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgc3RhdGljOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gVXNlIENTUyB0cmFuc2Zvcm1zIGluc3RlYWQgb2YgdG9wL2xlZnRcbiAgdXNlQ1NTVHJhbnNmb3JtczogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgdHJhbnNmb3JtU2NhbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIE90aGVyc1xuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIFNlbGVjdG9yIGZvciBkcmFnZ2FibGUgaGFuZGxlXG4gIGhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gU2VsZWN0b3IgZm9yIGRyYWdnYWJsZSBjYW5jZWwgKHNlZSByZWFjdC1kcmFnZ2FibGUpXG4gIGNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhIGRyb3BwaW5nIGVsZW1lbnRcbiAgZHJvcHBpbmdQb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbGVmdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRvcDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG4gIH0pXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShHcmlkSXRlbSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBjbGFzc05hbWU6IFwiXCIsXG4gIGNhbmNlbDogXCJcIixcbiAgaGFuZGxlOiBcIlwiLFxuICBtaW5IOiAxLFxuICBtaW5XOiAxLFxuICBtYXhIOiBJbmZpbml0eSxcbiAgbWF4VzogSW5maW5pdHksXG4gIHRyYW5zZm9ybVNjYWxlOiAxXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/GridItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _GridItem = _interopRequireDefault(__webpack_require__(/*! ./GridItem */ \"(ssr)/./node_modules/react-grid-layout/build/GridItem.js\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout,\n        activeDrag: placeholder\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      const {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !e.nativeEvent.target?.classList.contains(layoutClassName)) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver?.(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n\n      // $FlowIgnore missing def\n      const gridRect = e.currentTarget.getBoundingClientRect(); // The grid's position in the viewport\n\n      // Calculate the mouse position relative to the grid\n      const layerX = e.clientX - gridRect.left;\n      const layerY = e.clientY - gridRect.top;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: `react-grid-placeholder ${this.state.resizing ? \"placeholder-resizing\" : \"\"}`,\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports[\"default\"] = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsbUNBQW1DLG1CQUFPLENBQUMsb0RBQU07QUFDakQsYUFBYSxtQkFBTyxDQUFDLHNFQUFTO0FBQzlCLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFrQjtBQUNoRCx1Q0FBdUMsbUJBQU8sQ0FBQyw0RUFBWTtBQUMzRCx1REFBdUQsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDM0YsdUNBQXVDLHVDQUF1QztBQUM5RSx1Q0FBdUMsK0NBQStDLDBDQUEwQyxrREFBa0QsbUJBQW1CO0FBQ3JNLHlDQUF5Qyx1Q0FBdUMsMkVBQTJFLGNBQWMscUNBQXFDLG9DQUFvQyxVQUFVLGlCQUFpQixnRUFBZ0Usc0ZBQXNGLDBEQUEwRCx3RUFBd0U7QUFDcmlCLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTtBQUNuVTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxlQUFlO0FBQ2pCO0FBQ0EsbUJBQW1CLGlCQUFpQix3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixtQkFBbUIsc0JBQXNCLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrREFBa0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlbWl1bS1iZW50by1ncmlkLWVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZWFjdEdyaWRMYXlvdXQuanM/MjhjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Zhc3RFcXVhbHMgPSByZXF1aXJlKFwiZmFzdC1lcXVhbHNcIik7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfY2FsY3VsYXRlVXRpbHMgPSByZXF1aXJlKFwiLi9jYWxjdWxhdGVVdGlsc1wiKTtcbnZhciBfR3JpZEl0ZW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0dyaWRJdGVtXCIpKTtcbnZhciBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBkZWZhdWx0OiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbi5kZWZhdWx0ID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIENoaWxkcmVuQXJyYXkgYXMgUmVhY3RDaGlsZHJlbkFycmF5LFxuICBFbGVtZW50IGFzIFJlYWN0RWxlbWVudFxufSBmcm9tIFwicmVhY3RcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIENvbXBhY3RUeXBlLFxuICBHcmlkUmVzaXplRXZlbnQsXG4gIEdyaWREcmFnRXZlbnQsXG4gIERyYWdPdmVyRXZlbnQsXG4gIExheW91dCxcbiAgRHJvcHBpbmdQb3NpdGlvbixcbiAgTGF5b3V0SXRlbVxufSBmcm9tIFwiLi91dGlsc1wiOyovXG4vLyBUeXBlc1xuLyo6OiBpbXBvcnQgdHlwZSB7IFBvc2l0aW9uUGFyYW1zIH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjsqL1xuLyo6OiB0eXBlIFN0YXRlID0ge1xuICBhY3RpdmVEcmFnOiA/TGF5b3V0SXRlbSxcbiAgbGF5b3V0OiBMYXlvdXQsXG4gIG1vdW50ZWQ6IGJvb2xlYW4sXG4gIG9sZERyYWdJdGVtOiA/TGF5b3V0SXRlbSxcbiAgb2xkTGF5b3V0OiA/TGF5b3V0LFxuICBvbGRSZXNpemVJdGVtOiA/TGF5b3V0SXRlbSxcbiAgcmVzaXppbmc6IGJvb2xlYW4sXG4gIGRyb3BwaW5nRE9NTm9kZTogP1JlYWN0RWxlbWVudDxhbnk+LFxuICBkcm9wcGluZ1Bvc2l0aW9uPzogRHJvcHBpbmdQb3NpdGlvbixcbiAgLy8gTWlycm9yZWQgcHJvcHNcbiAgY2hpbGRyZW46IFJlYWN0Q2hpbGRyZW5BcnJheTxSZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNvbXBhY3RUeXBlPzogQ29tcGFjdFR5cGUsXG4gIHByb3BzTGF5b3V0PzogTGF5b3V0XG59OyovXG4vKjo6IGltcG9ydCB0eXBlIHsgUHJvcHMsIERlZmF1bHRQcm9wcyB9IGZyb20gXCIuL1JlYWN0R3JpZExheW91dFByb3BUeXBlc1wiOyovXG4vLyBFbmQgVHlwZXNcbmNvbnN0IGxheW91dENsYXNzTmFtZSA9IFwicmVhY3QtZ3JpZC1sYXlvdXRcIjtcbmxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbi8vIFRyeS4uLmNhdGNoIHdpbGwgcHJvdGVjdCBmcm9tIG5hdmlnYXRvciBub3QgZXhpc3RpbmcgKGUuZy4gbm9kZSkgb3IgYSBiYWQgaW1wbGVtZW50YXRpb24gb2YgbmF2aWdhdG9yXG50cnkge1xuICBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59IGNhdGNoIChlKSB7XG4gIC8qIElnbm9yZSAqL1xufVxuXG4vKipcbiAqIEEgcmVhY3RpdmUsIGZsdWlkIGdyaWQgbGF5b3V0IHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUgY29tcG9uZW50cy5cbiAqL1xuXG5jbGFzcyBSZWFjdEdyaWRMYXlvdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8UHJvcHMsIFN0YXRlPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICBsYXlvdXQ6ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKHRoaXMucHJvcHMubGF5b3V0LCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLnByb3BzLmNvbHMsXG4gICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdmVydGljYWxDb21wYWN0OiBmYWxzZVxuICAgICAgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIHRoaXMucHJvcHMuYWxsb3dPdmVybGFwKSxcbiAgICAgIG1vdW50ZWQ6IGZhbHNlLFxuICAgICAgb2xkRHJhZ0l0ZW06IG51bGwsXG4gICAgICBvbGRMYXlvdXQ6IG51bGwsXG4gICAgICBvbGRSZXNpemVJdGVtOiBudWxsLFxuICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgZHJvcHBpbmdET01Ob2RlOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ0VudGVyQ291bnRlclwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGRyYWdnaW5nIHN0YXJ0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpIElkIG9mIHRoZSBjaGlsZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RhcnRcIiwgKGkgLyo6IHN0cmluZyovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8sIF9yZWYgLyo6OiAqLykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSAvKjogR3JpZERyYWdFdmVudCovID0gX3JlZiAvKjogR3JpZERyYWdFdmVudCovO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuXG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgKGRpc3BsYXkgb25seSlcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICB3OiBsLncsXG4gICAgICAgIGg6IGwuaCxcbiAgICAgICAgeDogbC54LFxuICAgICAgICB5OiBsLnksXG4gICAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgICBpOiBpXG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9sZERyYWdJdGVtOiAoMCwgX3V0aWxzLmNsb25lTGF5b3V0SXRlbSkobCksXG4gICAgICAgIG9sZExheW91dDogbGF5b3V0LFxuICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWdTdGFydChsYXlvdXQsIGwsIGwsIG51bGwsIGUsIG5vZGUpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVhY2ggZHJhZyBtb3ZlbWVudCBjcmVhdGUgYSBuZXcgZHJhZ2VsZW1lbnQgYW5kIG1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaSBJZCBvZiB0aGUgY2hpbGRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIG1vdXNlZG93biBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoaSwgeCwgeSwgX3JlZjIpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkRHJhZ0l0ZW1cbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgbGV0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgYWxsb3dPdmVybGFwLFxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICBpZiAoIWwpIHJldHVybjtcblxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIChkaXNwbGF5IG9ubHkpXG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgdzogbC53LFxuICAgICAgICBoOiBsLmgsXG4gICAgICAgIHg6IGwueCxcbiAgICAgICAgeTogbC55LFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgICAgaTogaVxuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCB0byB0aGUgZHJhZ2dlZCBsb2NhdGlvbi5cbiAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShsYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIGFsbG93T3ZlcmxhcCk7XG4gICAgICB0aGlzLnByb3BzLm9uRHJhZyhsYXlvdXQsIG9sZERyYWdJdGVtLCBsLCBwbGFjZWhvbGRlciwgZSwgbm9kZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGF5b3V0OiBhbGxvd092ZXJsYXAgPyBsYXlvdXQgOiAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dCwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMpLFxuICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hlbiBkcmFnZ2luZyBzdG9wcywgZmlndXJlIG91dCB3aGljaCBwb3NpdGlvbiB0aGUgZWxlbWVudCBpcyBjbG9zZXN0IHRvIGFuZCB1cGRhdGUgaXRzIHggYW5kIHkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpIEluZGV4IG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIG1vdXNlZG93biBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0b3BcIiwgKGksIHgsIHksIF9yZWYzKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gX3JlZjM7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlRHJhZykgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGREcmFnSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xzLFxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uLFxuICAgICAgICBhbGxvd092ZXJsYXBcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IGhlcmVcbiAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShsYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIGFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIFNldCBzdGF0ZVxuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwID8gbGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25EcmFnU3RvcChuZXdMYXlvdXQsIG9sZERyYWdJdGVtLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkTGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgb2xkRHJhZ0l0ZW06IG51bGwsXG4gICAgICAgIG9sZExheW91dDogbnVsbFxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCwgb2xkTGF5b3V0KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0YXJ0XCIsIChpLCB3LCBoLCBfcmVmNCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9sZFJlc2l6ZUl0ZW06ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXRJdGVtKShsKSxcbiAgICAgICAgb2xkTGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgICAgcmVzaXppbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0YXJ0KGxheW91dCwgbCwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVcIiwgKGksIHcsIGgsIF9yZWY1KSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBzaXplLFxuICAgICAgICBoYW5kbGVcbiAgICAgIH0gPSBfcmVmNTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkUmVzaXplSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbHMsXG4gICAgICAgIHByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgIGFsbG93T3ZlcmxhcFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBsZXQgc2hvdWxkTW92ZUl0ZW0gPSBmYWxzZTtcbiAgICAgIGxldCBmaW5hbExheW91dDtcbiAgICAgIGxldCB4O1xuICAgICAgbGV0IHk7XG4gICAgICBjb25zdCBbbmV3TGF5b3V0LCBsXSA9ICgwLCBfdXRpbHMud2l0aExheW91dEl0ZW0pKGxheW91dCwgaSwgbCA9PiB7XG4gICAgICAgIGxldCBoYXNDb2xsaXNpb25zO1xuICAgICAgICB4ID0gbC54O1xuICAgICAgICB5ID0gbC55O1xuICAgICAgICBpZiAoW1wic3dcIiwgXCJ3XCIsIFwibndcIiwgXCJuXCIsIFwibmVcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChbXCJzd1wiLCBcIm53XCIsIFwid1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB4ID0gbC54ICsgKGwudyAtIHcpO1xuICAgICAgICAgICAgdyA9IGwueCAhPT0geCAmJiB4IDwgMCA/IGwudyA6IHc7XG4gICAgICAgICAgICB4ID0geCA8IDAgPyAwIDogeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFtcIm5lXCIsIFwiblwiLCBcIm53XCJdLmluZGV4T2YoaGFuZGxlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHkgPSBsLnkgKyAobC5oIC0gaCk7XG4gICAgICAgICAgICBoID0gbC55ICE9PSB5ICYmIHkgPCAwID8gbC5oIDogaDtcbiAgICAgICAgICAgIHkgPSB5IDwgMCA/IDAgOiB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaG91bGRNb3ZlSXRlbSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGhpbmcgbGlrZSBxdWFkIHRyZWUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgLy8gdG8gZmluZCBjb2xsaXNpb25zIGZhc3RlclxuICAgICAgICBpZiAocHJldmVudENvbGxpc2lvbiAmJiAhYWxsb3dPdmVybGFwKSB7XG4gICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9ICgwLCBfdXRpbHMuZ2V0QWxsQ29sbGlzaW9ucykobGF5b3V0LCB7XG4gICAgICAgICAgICAuLi5sLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH0pLmZpbHRlcihsYXlvdXRJdGVtID0+IGxheW91dEl0ZW0uaSAhPT0gbC5pKTtcbiAgICAgICAgICBoYXNDb2xsaXNpb25zID0gY29sbGlzaW9ucy5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY29sbGlkaW5nLCB3ZSBuZWVkIGFkanVzdCB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgaWYgKGhhc0NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGxheW91dEl0ZW0gZGltZW5zaW9ucyBpZiB0aGVyZSB3ZXJlIGNvbGxpc2lvbnNcbiAgICAgICAgICAgIHkgPSBsLnk7XG4gICAgICAgICAgICBoID0gbC5oO1xuICAgICAgICAgICAgeCA9IGwueDtcbiAgICAgICAgICAgIHcgPSBsLnc7XG4gICAgICAgICAgICBzaG91bGRNb3ZlSXRlbSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsLncgPSB3O1xuICAgICAgICBsLmggPSBoO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGRuJ3QgZXZlciBoYXBwZW4sIGJ1dCB0eXBlY2hlY2tpbmcgbWFrZXMgaXQgbmVjZXNzYXJ5XG4gICAgICBpZiAoIWwpIHJldHVybjtcbiAgICAgIGZpbmFsTGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgaWYgKHNob3VsZE1vdmVJdGVtKSB7XG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgaXNVc2VyQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgZmluYWxMYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShuZXdMYXlvdXQsIGwsIHgsIHksIGlzVXNlckFjdGlvbiwgdGhpcy5wcm9wcy5wcmV2ZW50Q29sbGlzaW9uLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scywgYWxsb3dPdmVybGFwKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIGVsZW1lbnQgKGRpc3BsYXkgb25seSlcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICB3OiBsLncsXG4gICAgICAgIGg6IGwuaCxcbiAgICAgICAgeDogbC54LFxuICAgICAgICB5OiBsLnksXG4gICAgICAgIHN0YXRpYzogdHJ1ZSxcbiAgICAgICAgaTogaVxuICAgICAgfTtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemUoZmluYWxMYXlvdXQsIG9sZFJlc2l6ZUl0ZW0sIGwsIHBsYWNlaG9sZGVyLCBlLCBub2RlKTtcblxuICAgICAgLy8gUmUtY29tcGFjdCB0aGUgbmV3TGF5b3V0IGFuZCBzZXQgdGhlIGRyYWcgcGxhY2Vob2xkZXIuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGF5b3V0OiBhbGxvd092ZXJsYXAgPyBmaW5hbExheW91dCA6ICgwLCBfdXRpbHMuY29tcGFjdCkoZmluYWxMYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKSxcbiAgICAgICAgYWN0aXZlRHJhZzogcGxhY2Vob2xkZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVzaXplU3RvcFwiLCAoaSwgdywgaCwgX3JlZjYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmNjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBvbGRSZXNpemVJdGVtXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgYWxsb3dPdmVybGFwXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG5cbiAgICAgIC8vIFNldCBzdGF0ZVxuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gYWxsb3dPdmVybGFwID8gbGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdG9wKG5ld0xheW91dCwgb2xkUmVzaXplSXRlbSwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZExheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIG9sZFJlc2l6ZUl0ZW06IG51bGwsXG4gICAgICAgIG9sZExheW91dDogbnVsbCxcbiAgICAgICAgcmVzaXppbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQobmV3TGF5b3V0LCBvbGRMYXlvdXQpO1xuICAgIH0pO1xuICAgIC8vIENhbGxlZCB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50LiBQYXJ0IG9mIGJyb3dzZXIgbmF0aXZlIGRyYWcvZHJvcCBBUEkuXG4gICAgLy8gTmF0aXZlIGV2ZW50IHRhcmdldCBtaWdodCBiZSB0aGUgbGF5b3V0IGl0c2VsZiwgb3IgYW4gZWxlbWVudCB3aXRoaW4gdGhlIGxheW91dC5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdPdmVyXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgZXZlbnRzIGZyb20gbGF5b3V0J3MgY2hpbGRyZW4gaW4gRmlyZWZveFxuICAgICAgLy8gdG8gYXZvaWQgdW5wcmVkaWN0YWJsZSBqdW1waW5nIG9mIGEgZHJvcHBpbmcgcGxhY2Vob2xkZXJcbiAgICAgIC8vIEZJWE1FIHJlbW92ZSB0aGlzIGhhY2tcbiAgICAgIGlmIChpc0ZpcmVmb3ggJiZcbiAgICAgIC8vICRGbG93SWdub3JlIGNhbid0IGZpZ3VyZSB0aGlzIG91dFxuICAgICAgIWUubmF0aXZlRXZlbnQudGFyZ2V0Py5jbGFzc0xpc3QuY29udGFpbnMobGF5b3V0Q2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRyb3BwaW5nSXRlbSxcbiAgICAgICAgb25Ecm9wRHJhZ092ZXIsXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgY29scyxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICBtYXhSb3dzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgICAgdHJhbnNmb3JtU2NhbGVcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgLy8gQWxsb3cgdXNlciB0byBjdXN0b21pemUgdGhlIGRyb3BwaW5nIGl0ZW0gb3Igc2hvcnQtY2lyY3VpdCB0aGUgZHJvcCBiYXNlZCBvbiB0aGUgcmVzdWx0c1xuICAgICAgLy8gb2YgdGhlIGBvbkRyYWdPdmVyKGU6IEV2ZW50KWAgY2FsbGJhY2suXG4gICAgICBjb25zdCBvbkRyYWdPdmVyUmVzdWx0ID0gb25Ecm9wRHJhZ092ZXI/LihlKTtcbiAgICAgIGlmIChvbkRyYWdPdmVyUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbERyb3BwaW5nSXRlbSA9IHtcbiAgICAgICAgLi4uZHJvcHBpbmdJdGVtLFxuICAgICAgICAuLi5vbkRyYWdPdmVyUmVzdWx0XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAvLyAkRmxvd0lnbm9yZSBtaXNzaW5nIGRlZlxuICAgICAgY29uc3QgZ3JpZFJlY3QgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFRoZSBncmlkJ3MgcG9zaXRpb24gaW4gdGhlIHZpZXdwb3J0XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGdyaWRcbiAgICAgIGNvbnN0IGxheWVyWCA9IGUuY2xpZW50WCAtIGdyaWRSZWN0LmxlZnQ7XG4gICAgICBjb25zdCBsYXllclkgPSBlLmNsaWVudFkgLSBncmlkUmVjdC50b3A7XG4gICAgICBjb25zdCBkcm9wcGluZ1Bvc2l0aW9uID0ge1xuICAgICAgICBsZWZ0OiBsYXllclggLyB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgdG9wOiBsYXllclkgLyB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgZVxuICAgICAgfTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8gPSB7XG4gICAgICAgICAgY29scyxcbiAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgbWF4Um93cyxcbiAgICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRQb3NpdGlvbiA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKShwb3NpdGlvblBhcmFtcywgbGF5ZXJZLCBsYXllclgsIGZpbmFsRHJvcHBpbmdJdGVtLncsIGZpbmFsRHJvcHBpbmdJdGVtLmgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkcm9wcGluZ0RPTU5vZGU6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleTogZmluYWxEcm9wcGluZ0l0ZW0uaVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRyb3BwaW5nUG9zaXRpb24sXG4gICAgICAgICAgbGF5b3V0OiBbLi4ubGF5b3V0LCB7XG4gICAgICAgICAgICAuLi5maW5hbERyb3BwaW5nSXRlbSxcbiAgICAgICAgICAgIHg6IGNhbGN1bGF0ZWRQb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogY2FsY3VsYXRlZFBvc2l0aW9uLnksXG4gICAgICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgaXNEcmFnZ2FibGU6IHRydWVcbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcFxuICAgICAgICB9ID0gdGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IGxlZnQgIT0gbGF5ZXJYIHx8IHRvcCAhPSBsYXllclk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcHBpbmdQb3NpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRyb3BwaW5nSXRlbSxcbiAgICAgICAgY29sc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dC5maWx0ZXIobCA9PiBsLmkgIT09IGRyb3BwaW5nSXRlbS5pKSwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIHRoaXMucHJvcHMuYWxsb3dPdmVybGFwKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgZHJvcHBpbmdET01Ob2RlOiBudWxsLFxuICAgICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ0xlYXZlXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRyYWdFbnRlckNvdW50ZXItLTtcblxuICAgICAgLy8gb25EcmFnTGVhdmUgY2FuIGJlIHRyaWdnZXJlZCBvbiBlYWNoIGxheW91dCdzIGNoaWxkLlxuICAgICAgLy8gQnV0IHdlIGtub3cgdGhhdCBjb3VudCBvZiBkcmFnRW50ZXIgYW5kIGRyYWdMZWF2ZSBldmVudHNcbiAgICAgIC8vIHdpbGwgYmUgYmFsYW5jZWQgYWZ0ZXIgbGVhdmluZyB0aGUgbGF5b3V0J3MgY29udGFpbmVyXG4gICAgICAvLyBzbyB3ZSBjYW4gaW5jcmVhc2UgYW5kIGRlY3JlYXNlIGNvdW50IG9mIGRyYWdFbnRlciBhbmRcbiAgICAgIC8vIHdoZW4gaXQnbGwgYmUgZXF1YWwgdG8gMCB3ZSdsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICBpZiAodGhpcy5kcmFnRW50ZXJDb3VudGVyID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ0VudGVyXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRyYWdFbnRlckNvdW50ZXIrKztcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyb3BcIiwgKGUgLyo6IEV2ZW50Ki8pID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkcm9wcGluZ0l0ZW1cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgaXRlbSA9IGxheW91dC5maW5kKGwgPT4gbC5pID09PSBkcm9wcGluZ0l0ZW0uaSk7XG5cbiAgICAgIC8vIHJlc2V0IGRyYWdFbnRlciBjb3VudGVyIG9uIGRyb3BcbiAgICAgIHRoaXMuZHJhZ0VudGVyQ291bnRlciA9IDA7XG4gICAgICB0aGlzLnJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgIHRoaXMucHJvcHMub25Ecm9wKGxheW91dCwgaXRlbSwgZSk7XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb3VudGVkOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gUG9zc2libHkgY2FsbCBiYWNrIHdpdGggbGF5b3V0IG9uIG1vdW50LiBUaGlzIHNob3VsZCBiZSBkb25lIGFmdGVyIGNvcnJlY3RpbmcgdGhlIGxheW91dCB3aWR0aFxuICAgIC8vIHRvIGVuc3VyZSB3ZSBkb24ndCByZXJlbmRlciB3aXRoIHRoZSB3cm9uZyB3aWR0aC5cbiAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKHRoaXMuc3RhdGUubGF5b3V0LCB0aGlzLnByb3BzLmxheW91dCk7XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMgLyo6IFByb3BzKi8sIHByZXZTdGF0ZSAvKjogU3RhdGUqLykgLyo6ICRTaGFwZTxTdGF0ZT4gfCBudWxsKi97XG4gICAgbGV0IG5ld0xheW91dEJhc2U7XG4gICAgaWYgKHByZXZTdGF0ZS5hY3RpdmVEcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgY29tcGFjdFR5cGVcbiAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IGxheW91dCBkaXJlY3RseS5cbiAgICBpZiAoISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKG5leHRQcm9wcy5sYXlvdXQsIHByZXZTdGF0ZS5wcm9wc0xheW91dCkgfHwgbmV4dFByb3BzLmNvbXBhY3RUeXBlICE9PSBwcmV2U3RhdGUuY29tcGFjdFR5cGUpIHtcbiAgICAgIG5ld0xheW91dEJhc2UgPSBuZXh0UHJvcHMubGF5b3V0O1xuICAgIH0gZWxzZSBpZiAoISgwLCBfdXRpbHMuY2hpbGRyZW5FcXVhbCkobmV4dFByb3BzLmNoaWxkcmVuLCBwcmV2U3RhdGUuY2hpbGRyZW4pKSB7XG4gICAgICAvLyBJZiBjaGlsZHJlbiBjaGFuZ2UsIGFsc28gcmVnZW5lcmF0ZSB0aGUgbGF5b3V0LiBVc2Ugb3VyIHN0YXRlXG4gICAgICAvLyBhcyB0aGUgYmFzZSBpbiBjYXNlIGJlY2F1c2UgaXQgbWF5IGJlIG1vcmUgdXAgdG8gZGF0ZSB0aGFuXG4gICAgICAvLyB3aGF0IGlzIGluIHByb3BzLlxuICAgICAgbmV3TGF5b3V0QmFzZSA9IHByZXZTdGF0ZS5sYXlvdXQ7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byByZWdlbmVyYXRlIHRoZSBsYXlvdXQuXG4gICAgaWYgKG5ld0xheW91dEJhc2UpIHtcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKG5ld0xheW91dEJhc2UsIG5leHRQcm9wcy5jaGlsZHJlbiwgbmV4dFByb3BzLmNvbHMsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKG5leHRQcm9wcyksIG5leHRQcm9wcy5hbGxvd092ZXJsYXApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGVzZSBwcm9wcyB0byBzdGF0ZSBmb3IgdXNpbmdcbiAgICAgICAgLy8gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGluc3RlYWQgb2YgY29tcG9uZW50RGlkTW91bnQgKGluIHdoaWNoIHdlIHdvdWxkIGdldCBleHRyYSByZXJlbmRlcilcbiAgICAgICAgY29tcGFjdFR5cGU6IG5leHRQcm9wcy5jb21wYWN0VHlwZSxcbiAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcHJvcHNMYXlvdXQ6IG5leHRQcm9wcy5sYXlvdXRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMgLyo6IFByb3BzKi8sIG5leHRTdGF0ZSAvKjogU3RhdGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgICByZXR1cm4gKFxuICAgICAgLy8gTk9URTogdGhpcyBpcyBhbG1vc3QgYWx3YXlzIHVuZXF1YWwuIFRoZXJlZm9yZSB0aGUgb25seSB3YXkgdG8gZ2V0IGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgLy8gZnJvbSBTQ1UgaXMgaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSBtZW1vaXplcyBjaGlsZHJlbi4gSWYgdGhleSBkbywgYW5kIHRoZXkgY2FuXG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyBwcm9wZXJseSwgcGVyZm9ybWFuY2Ugd2lsbCBpbmNyZWFzZS5cbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbiB8fCAhKDAsIF91dGlscy5mYXN0UkdMUHJvcHNFcXVhbCkodGhpcy5wcm9wcywgbmV4dFByb3BzLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpIHx8IHRoaXMuc3RhdGUuYWN0aXZlRHJhZyAhPT0gbmV4dFN0YXRlLmFjdGl2ZURyYWcgfHwgdGhpcy5zdGF0ZS5tb3VudGVkICE9PSBuZXh0U3RhdGUubW91bnRlZCB8fCB0aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb24gIT09IG5leHRTdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uXG4gICAgKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzIC8qOiBQcm9wcyovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlRHJhZykge1xuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gdGhpcy5zdGF0ZS5sYXlvdXQ7XG4gICAgICBjb25zdCBvbGRMYXlvdXQgPSBwcmV2U3RhdGUubGF5b3V0O1xuICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgYSBwaXhlbCB2YWx1ZSBmb3IgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7U3RyaW5nfSBDb250YWluZXIgaGVpZ2h0IGluIHBpeGVscy5cbiAgICovXG4gIGNvbnRhaW5lckhlaWdodCgpIC8qOiA/c3RyaW5nKi97XG4gICAgaWYgKCF0aGlzLnByb3BzLmF1dG9TaXplKSByZXR1cm47XG4gICAgY29uc3QgbmJSb3cgPSAoMCwgX3V0aWxzLmJvdHRvbSkodGhpcy5zdGF0ZS5sYXlvdXQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmdZID0gdGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nID8gdGhpcy5wcm9wcy5jb250YWluZXJQYWRkaW5nWzFdIDogdGhpcy5wcm9wcy5tYXJnaW5bMV07XG4gICAgcmV0dXJuIG5iUm93ICogdGhpcy5wcm9wcy5yb3dIZWlnaHQgKyAobmJSb3cgLSAxKSAqIHRoaXMucHJvcHMubWFyZ2luWzFdICsgY29udGFpbmVyUGFkZGluZ1kgKiAyICsgXCJweFwiO1xuICB9XG4gIG9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCAvKjogTGF5b3V0Ki8sIG9sZExheW91dCAvKjogP0xheW91dCovKSB7XG4gICAgaWYgKCFvbGRMYXlvdXQpIG9sZExheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkob2xkTGF5b3V0LCBuZXdMYXlvdXQpKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTGF5b3V0Q2hhbmdlKG5ld0xheW91dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGFjZWhvbGRlciBvYmplY3QuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFBsYWNlaG9sZGVyIGRpdi5cbiAgICovXG4gIHBsYWNlaG9sZGVyKCkgLyo6ID9SZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZURyYWdcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWFjdGl2ZURyYWcpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgY29scyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICByb3dIZWlnaHQsXG4gICAgICBtYXhSb3dzLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB7Li4udGhpcy5zdGF0ZS5hY3RpdmVEcmFnfSBpcyBwcmV0dHkgc2xvdywgYWN0dWFsbHlcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0dyaWRJdGVtLmRlZmF1bHQsIHtcbiAgICAgIHc6IGFjdGl2ZURyYWcudyxcbiAgICAgIGg6IGFjdGl2ZURyYWcuaCxcbiAgICAgIHg6IGFjdGl2ZURyYWcueCxcbiAgICAgIHk6IGFjdGl2ZURyYWcueSxcbiAgICAgIGk6IGFjdGl2ZURyYWcuaSxcbiAgICAgIGNsYXNzTmFtZTogYHJlYWN0LWdyaWQtcGxhY2Vob2xkZXIgJHt0aGlzLnN0YXRlLnJlc2l6aW5nID8gXCJwbGFjZWhvbGRlci1yZXNpemluZ1wiIDogXCJcIn1gLFxuICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgY29sczogY29scyxcbiAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sXG4gICAgICBtYXhSb3dzOiBtYXhSb3dzLFxuICAgICAgcm93SGVpZ2h0OiByb3dIZWlnaHQsXG4gICAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgICBpc1Jlc2l6YWJsZTogZmFsc2UsXG4gICAgICBpc0JvdW5kZWQ6IGZhbHNlLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlOiB0cmFuc2Zvcm1TY2FsZVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGdyaWQgaXRlbSwgc2V0IGl0cyBzdHlsZSBhdHRyaWJ1dGVzICYgc3Vycm91bmQgaW4gYSA8RHJhZ2dhYmxlPi5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgUmVhY3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgRWxlbWVudCB3cmFwcGVkIGluIGRyYWdnYWJsZSBhbmQgcHJvcGVybHkgcGxhY2VkLlxuICAgKi9cbiAgcHJvY2Vzc0dyaWRJdGVtKGNoaWxkIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovLCBpc0Ryb3BwaW5nSXRlbSAvKjogYm9vbGVhbiovKSAvKjogP1JlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgaWYgKCFjaGlsZCB8fCAhY2hpbGQua2V5KSByZXR1cm47XG4gICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkodGhpcy5zdGF0ZS5sYXlvdXQsIFN0cmluZyhjaGlsZC5rZXkpKTtcbiAgICBpZiAoIWwpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgY29scyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICByb3dIZWlnaHQsXG4gICAgICBtYXhSb3dzLFxuICAgICAgaXNEcmFnZ2FibGUsXG4gICAgICBpc1Jlc2l6YWJsZSxcbiAgICAgIGlzQm91bmRlZCxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgIGRyYWdnYWJsZUNhbmNlbCxcbiAgICAgIGRyYWdnYWJsZUhhbmRsZSxcbiAgICAgIHJlc2l6ZUhhbmRsZXMsXG4gICAgICByZXNpemVIYW5kbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBtb3VudGVkLFxuICAgICAgZHJvcHBpbmdQb3NpdGlvblxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHVzZXIgbWFuaXB1bGF0aW9ucyBwb3NzaWJsZS5cbiAgICAvLyBJZiBhbiBpdGVtIGlzIHN0YXRpYywgaXQgY2FuJ3QgYmUgbWFuaXB1bGF0ZWQgYnkgZGVmYXVsdC5cbiAgICAvLyBBbnkgcHJvcGVydGllcyBkZWZpbmVkIGRpcmVjdGx5IG9uIHRoZSBncmlkIGl0ZW0gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgY29uc3QgZHJhZ2dhYmxlID0gdHlwZW9mIGwuaXNEcmFnZ2FibGUgPT09IFwiYm9vbGVhblwiID8gbC5pc0RyYWdnYWJsZSA6ICFsLnN0YXRpYyAmJiBpc0RyYWdnYWJsZTtcbiAgICBjb25zdCByZXNpemFibGUgPSB0eXBlb2YgbC5pc1Jlc2l6YWJsZSA9PT0gXCJib29sZWFuXCIgPyBsLmlzUmVzaXphYmxlIDogIWwuc3RhdGljICYmIGlzUmVzaXphYmxlO1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXNPcHRpb25zID0gbC5yZXNpemVIYW5kbGVzIHx8IHJlc2l6ZUhhbmRsZXM7XG5cbiAgICAvLyBpc0JvdW5kZWQgc2V0IG9uIGNoaWxkIGlmIHNldCBvbiBwYXJlbnQsIGFuZCBjaGlsZCBpcyBub3QgZXhwbGljaXRseSBmYWxzZVxuICAgIGNvbnN0IGJvdW5kZWQgPSBkcmFnZ2FibGUgJiYgaXNCb3VuZGVkICYmIGwuaXNCb3VuZGVkICE9PSBmYWxzZTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0dyaWRJdGVtLmRlZmF1bHQsIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgIGNvbHM6IGNvbHMsXG4gICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luLFxuICAgICAgbWF4Um93czogbWF4Um93cyxcbiAgICAgIHJvd0hlaWdodDogcm93SGVpZ2h0LFxuICAgICAgY2FuY2VsOiBkcmFnZ2FibGVDYW5jZWwsXG4gICAgICBoYW5kbGU6IGRyYWdnYWJsZUhhbmRsZSxcbiAgICAgIG9uRHJhZ1N0b3A6IHRoaXMub25EcmFnU3RvcCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnOiB0aGlzLm9uRHJhZyxcbiAgICAgIG9uUmVzaXplU3RhcnQ6IHRoaXMub25SZXNpemVTdGFydCxcbiAgICAgIG9uUmVzaXplOiB0aGlzLm9uUmVzaXplLFxuICAgICAgb25SZXNpemVTdG9wOiB0aGlzLm9uUmVzaXplU3RvcCxcbiAgICAgIGlzRHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBpc1Jlc2l6YWJsZTogcmVzaXphYmxlLFxuICAgICAgaXNCb3VuZGVkOiBib3VuZGVkLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyAmJiBtb3VudGVkLFxuICAgICAgdXNlUGVyY2VudGFnZXM6ICFtb3VudGVkLFxuICAgICAgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLFxuICAgICAgdzogbC53LFxuICAgICAgaDogbC5oLFxuICAgICAgeDogbC54LFxuICAgICAgeTogbC55LFxuICAgICAgaTogbC5pLFxuICAgICAgbWluSDogbC5taW5ILFxuICAgICAgbWluVzogbC5taW5XLFxuICAgICAgbWF4SDogbC5tYXhILFxuICAgICAgbWF4VzogbC5tYXhXLFxuICAgICAgc3RhdGljOiBsLnN0YXRpYyxcbiAgICAgIGRyb3BwaW5nUG9zaXRpb246IGlzRHJvcHBpbmdJdGVtID8gZHJvcHBpbmdQb3NpdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXNPcHRpb25zLFxuICAgICAgcmVzaXplSGFuZGxlOiByZXNpemVIYW5kbGVcbiAgICB9LCBjaGlsZCk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8XCJkaXZcIj4qL3tcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGlzRHJvcHBhYmxlLFxuICAgICAgaW5uZXJSZWZcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBtZXJnZWRDbGFzc05hbWUgPSAoMCwgX2Nsc3guZGVmYXVsdCkobGF5b3V0Q2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICAgIGNvbnN0IG1lcmdlZFN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCgpLFxuICAgICAgLi4uc3R5bGVcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZWRDbGFzc05hbWUsXG4gICAgICBzdHlsZTogbWVyZ2VkU3R5bGUsXG4gICAgICBvbkRyb3A6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyb3AgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ0xlYXZlOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25EcmFnTGVhdmUgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ0VudGVyOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25EcmFnRW50ZXIgOiBfdXRpbHMubm9vcCxcbiAgICAgIG9uRHJhZ092ZXI6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdPdmVyIDogX3V0aWxzLm5vb3BcbiAgICB9LCBSZWFjdC5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hpbGQgPT4gdGhpcy5wcm9jZXNzR3JpZEl0ZW0oY2hpbGQpKSwgaXNEcm9wcGFibGUgJiYgdGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUgJiYgdGhpcy5wcm9jZXNzR3JpZEl0ZW0odGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUsIHRydWUpLCB0aGlzLnBsYWNlaG9sZGVyKCkpO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFjdEdyaWRMYXlvdXQ7XG4vLyBUT0RPIHB1Ymxpc2ggaW50ZXJuYWwgUmVhY3RDbGFzcyBkaXNwbGF5TmFtZSB0cmFuc2Zvcm1cbl9kZWZpbmVQcm9wZXJ0eShSZWFjdEdyaWRMYXlvdXQsIFwiZGlzcGxheU5hbWVcIiwgXCJSZWFjdEdyaWRMYXlvdXRcIik7XG4vLyBSZWZhY3RvcmVkIHRvIGFub3RoZXIgbW9kdWxlIHRvIG1ha2Ugd2F5IGZvciBwcmV2YWxcbl9kZWZpbmVQcm9wZXJ0eShSZWFjdEdyaWRMYXlvdXQsIFwicHJvcFR5cGVzXCIsIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMuZGVmYXVsdCk7XG5fZGVmaW5lUHJvcGVydHkoUmVhY3RHcmlkTGF5b3V0LCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGF1dG9TaXplOiB0cnVlLFxuICBjb2xzOiAxMixcbiAgY2xhc3NOYW1lOiBcIlwiLFxuICBzdHlsZToge30sXG4gIGRyYWdnYWJsZUhhbmRsZTogXCJcIixcbiAgZHJhZ2dhYmxlQ2FuY2VsOiBcIlwiLFxuICBjb250YWluZXJQYWRkaW5nOiBudWxsLFxuICByb3dIZWlnaHQ6IDE1MCxcbiAgbWF4Um93czogSW5maW5pdHksXG4gIC8vIGluZmluaXRlIHZlcnRpY2FsIGdyb3d0aFxuICBsYXlvdXQ6IFtdLFxuICBtYXJnaW46IFsxMCwgMTBdLFxuICBpc0JvdW5kZWQ6IGZhbHNlLFxuICBpc0RyYWdnYWJsZTogdHJ1ZSxcbiAgaXNSZXNpemFibGU6IHRydWUsXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gIGlzRHJvcHBhYmxlOiBmYWxzZSxcbiAgdXNlQ1NTVHJhbnNmb3JtczogdHJ1ZSxcbiAgdHJhbnNmb3JtU2NhbGU6IDEsXG4gIHZlcnRpY2FsQ29tcGFjdDogdHJ1ZSxcbiAgY29tcGFjdFR5cGU6IFwidmVydGljYWxcIixcbiAgcHJldmVudENvbGxpc2lvbjogZmFsc2UsXG4gIGRyb3BwaW5nSXRlbToge1xuICAgIGk6IFwiX19kcm9wcGluZy1lbGVtX19cIixcbiAgICBoOiAxLFxuICAgIHc6IDFcbiAgfSxcbiAgcmVzaXplSGFuZGxlczogW1wic2VcIl0sXG4gIG9uTGF5b3V0Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25EcmFnU3RhcnQ6IF91dGlscy5ub29wLFxuICBvbkRyYWc6IF91dGlscy5ub29wLFxuICBvbkRyYWdTdG9wOiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemVTdGFydDogX3V0aWxzLm5vb3AsXG4gIG9uUmVzaXplOiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemVTdG9wOiBfdXRpbHMubm9vcCxcbiAgb25Ecm9wOiBfdXRpbHMubm9vcCxcbiAgb25Ecm9wRHJhZ092ZXI6IF91dGlscy5ub29wXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resizeHandleType = exports.resizeHandleAxesType = exports[\"default\"] = void 0;\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*:: import type {\n  Ref,\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  DragOverEvent,\n  EventCallback,\n  CompactType,\n  Layout,\n  LayoutItem,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: export type ReactRef<T: HTMLElement> = {|\n  +current: T | null\n|};*/\n// util\n/*:: export type ResizeHandle =\n  | ReactElement<any>\n  | ((\n      resizeHandleAxis: ResizeHandleAxis,\n      ref: ReactRef<HTMLElement>\n    ) => ReactElement<any>);*/\n// Defines which resize handles should be rendered (default: 'se')\n// Allows for any combination of:\n// 's' - South handle (bottom-center)\n// 'w' - West handle (left-center)\n// 'e' - East handle (right-center)\n// 'n' - North handle (top-center)\n// 'sw' - Southwest handle (bottom-left)\n// 'nw' - Northwest handle (top-left)\n// 'se' - Southeast handle (bottom-right)\n// 'ne' - Northeast handle (top-right)\nconst resizeHandleAxesType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"]));\n// Custom component for resize handles\nconst resizeHandleType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);\n/*:: export type Props = {|\n  className: string,\n  style: Object,\n  width: number,\n  autoSize: boolean,\n  cols: number,\n  draggableCancel: string,\n  draggableHandle: string,\n  verticalCompact: boolean,\n  compactType: CompactType,\n  layout: Layout,\n  margin: [number, number],\n  containerPadding: ?[number, number],\n  rowHeight: number,\n  maxRows: number,\n  isBounded: boolean,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isDroppable: boolean,\n  preventCollision: boolean,\n  useCSSTransforms: boolean,\n  transformScale: number,\n  droppingItem: $Shape<LayoutItem>,\n  resizeHandles: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n  allowOverlap: boolean,\n\n  // Callbacks\n  onLayoutChange: Layout => void,\n  onDrag: EventCallback,\n  onDragStart: EventCallback,\n  onDragStop: EventCallback,\n  onResize: EventCallback,\n  onResizeStart: EventCallback,\n  onResizeStop: EventCallback,\n  onDropDragOver: (e: DragOverEvent) => ?({| w?: number, h?: number |} | false),\n  onDrop: (layout: Layout, item: ?LayoutItem, e: Event) => void,\n  children: ReactChildrenArray<ReactElement<any>>,\n  innerRef?: Ref<\"div\">\n|};*/\n/*:: export type DefaultProps = $Diff<\n  Props,\n  {\n    children: ReactChildrenArray<ReactElement<any>>,\n    width: number\n  }\n>;*/\nvar _default = exports[\"default\"] = {\n  //\n  // Basic props\n  //\n  className: _propTypes.default.string,\n  style: _propTypes.default.object,\n  // This can be set explicitly. If it is not set, it will automatically\n  // be set to the container width. Note that resizes will *not* cause this to adjust.\n  // If you need that behavior, use WidthProvider.\n  width: _propTypes.default.number,\n  // If true, the container height swells and contracts to fit contents\n  autoSize: _propTypes.default.bool,\n  // # of cols.\n  cols: _propTypes.default.number,\n  // A selector that will not be draggable.\n  draggableCancel: _propTypes.default.string,\n  // A selector for the draggable handler\n  draggableHandle: _propTypes.default.string,\n  // Deprecated\n  verticalCompact: function (props /*: Props*/) {\n    if (props.verticalCompact === false && \"development\" !== \"production\") {\n      console.warn(\n      // eslint-disable-line no-console\n      \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" + 'Use `compactType`: \"horizontal\" | \"vertical\" | null.');\n    }\n  },\n  // Choose vertical or hotizontal compaction\n  compactType: (_propTypes.default.oneOf([\"vertical\", \"horizontal\"]) /*: ReactPropsChainableTypeChecker*/),\n  // layout is an array of object with the format:\n  // {x: Number, y: Number, w: Number, h: Number, i: String}\n  layout: function (props /*: Props*/) {\n    var layout = props.layout;\n    // I hope you're setting the data-grid property on the grid items\n    if (layout === undefined) return;\n    (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\").validateLayout)(layout, \"layout\");\n  },\n  //\n  // Grid Dimensions\n  //\n\n  // Margin between items [x, y] in px\n  margin: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Padding inside the container [x, y] in px\n  containerPadding: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Rows have a static height, but you can change this based on breakpoints if you like\n  rowHeight: _propTypes.default.number,\n  // Default Infinity, but you can specify a max here if you like.\n  // Note that this isn't fully fleshed out and won't error if you specify a layout that\n  // extends beyond the row capacity. It will, however, not allow users to drag/resize\n  // an item past the barrier. They can push items beyond the barrier, though.\n  // Intentionally not documented for this reason.\n  maxRows: _propTypes.default.number,\n  //\n  // Flags\n  //\n  isBounded: _propTypes.default.bool,\n  isDraggable: _propTypes.default.bool,\n  isResizable: _propTypes.default.bool,\n  // If true, grid can be placed one over the other.\n  allowOverlap: _propTypes.default.bool,\n  // If true, grid items won't change position when being dragged over.\n  preventCollision: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool,\n  // parent layout transform scale\n  transformScale: _propTypes.default.number,\n  // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n  isDroppable: _propTypes.default.bool,\n  // Resize handle options\n  resizeHandles: resizeHandleAxesType,\n  resizeHandle: resizeHandleType,\n  //\n  // Callbacks\n  //\n\n  // Callback so you can save the layout. Calls after each drag & resize stops.\n  onLayoutChange: _propTypes.default.func,\n  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n  onDragStart: _propTypes.default.func,\n  // Calls on each drag movement.\n  onDrag: _propTypes.default.func,\n  // Calls when drag is complete.\n  onDragStop: _propTypes.default.func,\n  //Calls when resize starts.\n  onResizeStart: _propTypes.default.func,\n  // Calls when resize movement happens.\n  onResize: _propTypes.default.func,\n  // Calls when resize is complete.\n  onResizeStop: _propTypes.default.func,\n  // Calls when some element is dropped.\n  onDrop: _propTypes.default.func,\n  //\n  // Other validations\n  //\n\n  droppingItem: (_propTypes.default.shape({\n    i: _propTypes.default.string.isRequired,\n    w: _propTypes.default.number.isRequired,\n    h: _propTypes.default.number.isRequired\n  }) /*: ReactPropsChainableTypeChecker*/),\n  // Children must not have duplicate keys.\n  children: function (props /*: Props*/, propName /*: string*/) {\n    const children = props[propName];\n\n    // Check children keys for duplicates. Throw if found.\n    const keys = {};\n    _react.default.Children.forEach(children, function (child) {\n      if (child?.key == null) return;\n      if (keys[child.key]) {\n        throw new Error('Duplicate child key \"' + child.key + '\" found! This will cause problems in ReactGridLayout.');\n      }\n      keys[child.key] = true;\n    });\n  },\n  // Optional ref for getting a reference for the wrapping div.\n  innerRef: _propTypes.default.any\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLGtCQUFlO0FBQ3pFLHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQiw2Q0FBNkM7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRCQUE0QjtBQUM5RjtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRHQUFpQztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZW1pdW0tYmVudG8tZ3JpZC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmpzP2UyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc2l6ZUhhbmRsZVR5cGUgPSBleHBvcnRzLnJlc2l6ZUhhbmRsZUF4ZXNUeXBlID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIFJlZixcbiAgQ2hpbGRyZW5BcnJheSBhcyBSZWFjdENoaWxkcmVuQXJyYXksXG4gIEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50XG59IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgRHJhZ092ZXJFdmVudCxcbiAgRXZlbnRDYWxsYmFjayxcbiAgQ29tcGFjdFR5cGUsXG4gIExheW91dCxcbiAgTGF5b3V0SXRlbSxcbiAgUmVzaXplSGFuZGxlQXhpc1xufSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlYWN0UmVmPFQ6IEhUTUxFbGVtZW50PiA9IHt8XG4gICtjdXJyZW50OiBUIHwgbnVsbFxufH07Ki9cbi8vIHV0aWxcbi8qOjogZXhwb3J0IHR5cGUgUmVzaXplSGFuZGxlID1cbiAgfCBSZWFjdEVsZW1lbnQ8YW55PlxuICB8ICgoXG4gICAgICByZXNpemVIYW5kbGVBeGlzOiBSZXNpemVIYW5kbGVBeGlzLFxuICAgICAgcmVmOiBSZWFjdFJlZjxIVE1MRWxlbWVudD5cbiAgICApID0+IFJlYWN0RWxlbWVudDxhbnk+KTsqL1xuLy8gRGVmaW5lcyB3aGljaCByZXNpemUgaGFuZGxlcyBzaG91bGQgYmUgcmVuZGVyZWQgKGRlZmF1bHQ6ICdzZScpXG4vLyBBbGxvd3MgZm9yIGFueSBjb21iaW5hdGlvbiBvZjpcbi8vICdzJyAtIFNvdXRoIGhhbmRsZSAoYm90dG9tLWNlbnRlcilcbi8vICd3JyAtIFdlc3QgaGFuZGxlIChsZWZ0LWNlbnRlcilcbi8vICdlJyAtIEVhc3QgaGFuZGxlIChyaWdodC1jZW50ZXIpXG4vLyAnbicgLSBOb3J0aCBoYW5kbGUgKHRvcC1jZW50ZXIpXG4vLyAnc3cnIC0gU291dGh3ZXN0IGhhbmRsZSAoYm90dG9tLWxlZnQpXG4vLyAnbncnIC0gTm9ydGh3ZXN0IGhhbmRsZSAodG9wLWxlZnQpXG4vLyAnc2UnIC0gU291dGhlYXN0IGhhbmRsZSAoYm90dG9tLXJpZ2h0KVxuLy8gJ25lJyAtIE5vcnRoZWFzdCBoYW5kbGUgKHRvcC1yaWdodClcbmNvbnN0IHJlc2l6ZUhhbmRsZUF4ZXNUeXBlIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyA9IGV4cG9ydHMucmVzaXplSGFuZGxlQXhlc1R5cGUgPSBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW1wic1wiLCBcIndcIiwgXCJlXCIsIFwiblwiLCBcInN3XCIsIFwibndcIiwgXCJzZVwiLCBcIm5lXCJdKSk7XG4vLyBDdXN0b20gY29tcG9uZW50IGZvciByZXNpemUgaGFuZGxlc1xuY29uc3QgcmVzaXplSGFuZGxlVHlwZSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8gPSBleHBvcnRzLnJlc2l6ZUhhbmRsZVR5cGUgPSBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSwgX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNdKTtcbi8qOjogZXhwb3J0IHR5cGUgUHJvcHMgPSB7fFxuICBjbGFzc05hbWU6IHN0cmluZyxcbiAgc3R5bGU6IE9iamVjdCxcbiAgd2lkdGg6IG51bWJlcixcbiAgYXV0b1NpemU6IGJvb2xlYW4sXG4gIGNvbHM6IG51bWJlcixcbiAgZHJhZ2dhYmxlQ2FuY2VsOiBzdHJpbmcsXG4gIGRyYWdnYWJsZUhhbmRsZTogc3RyaW5nLFxuICB2ZXJ0aWNhbENvbXBhY3Q6IGJvb2xlYW4sXG4gIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZSxcbiAgbGF5b3V0OiBMYXlvdXQsXG4gIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgY29udGFpbmVyUGFkZGluZzogP1tudW1iZXIsIG51bWJlcl0sXG4gIHJvd0hlaWdodDogbnVtYmVyLFxuICBtYXhSb3dzOiBudW1iZXIsXG4gIGlzQm91bmRlZDogYm9vbGVhbixcbiAgaXNEcmFnZ2FibGU6IGJvb2xlYW4sXG4gIGlzUmVzaXphYmxlOiBib29sZWFuLFxuICBpc0Ryb3BwYWJsZTogYm9vbGVhbixcbiAgcHJldmVudENvbGxpc2lvbjogYm9vbGVhbixcbiAgdXNlQ1NTVHJhbnNmb3JtczogYm9vbGVhbixcbiAgdHJhbnNmb3JtU2NhbGU6IG51bWJlcixcbiAgZHJvcHBpbmdJdGVtOiAkU2hhcGU8TGF5b3V0SXRlbT4sXG4gIHJlc2l6ZUhhbmRsZXM6IFJlc2l6ZUhhbmRsZUF4aXNbXSxcbiAgcmVzaXplSGFuZGxlPzogUmVzaXplSGFuZGxlLFxuICBhbGxvd092ZXJsYXA6IGJvb2xlYW4sXG5cbiAgLy8gQ2FsbGJhY2tzXG4gIG9uTGF5b3V0Q2hhbmdlOiBMYXlvdXQgPT4gdm9pZCxcbiAgb25EcmFnOiBFdmVudENhbGxiYWNrLFxuICBvbkRyYWdTdGFydDogRXZlbnRDYWxsYmFjayxcbiAgb25EcmFnU3RvcDogRXZlbnRDYWxsYmFjayxcbiAgb25SZXNpemU6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uUmVzaXplU3RhcnQ6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uUmVzaXplU3RvcDogRXZlbnRDYWxsYmFjayxcbiAgb25Ecm9wRHJhZ092ZXI6IChlOiBEcmFnT3ZlckV2ZW50KSA9PiA/KHt8IHc/OiBudW1iZXIsIGg/OiBudW1iZXIgfH0gfCBmYWxzZSksXG4gIG9uRHJvcDogKGxheW91dDogTGF5b3V0LCBpdGVtOiA/TGF5b3V0SXRlbSwgZTogRXZlbnQpID0+IHZvaWQsXG4gIGNoaWxkcmVuOiBSZWFjdENoaWxkcmVuQXJyYXk8UmVhY3RFbGVtZW50PGFueT4+LFxuICBpbm5lclJlZj86IFJlZjxcImRpdlwiPlxufH07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRGVmYXVsdFByb3BzID0gJERpZmY8XG4gIFByb3BzLFxuICB7XG4gICAgY2hpbGRyZW46IFJlYWN0Q2hpbGRyZW5BcnJheTxSZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgd2lkdGg6IG51bWJlclxuICB9XG4+OyovXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSB7XG4gIC8vXG4gIC8vIEJhc2ljIHByb3BzXG4gIC8vXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgc3R5bGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIC8vIFRoaXMgY2FuIGJlIHNldCBleHBsaWNpdGx5LiBJZiBpdCBpcyBub3Qgc2V0LCBpdCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgLy8gYmUgc2V0IHRvIHRoZSBjb250YWluZXIgd2lkdGguIE5vdGUgdGhhdCByZXNpemVzIHdpbGwgKm5vdCogY2F1c2UgdGhpcyB0byBhZGp1c3QuXG4gIC8vIElmIHlvdSBuZWVkIHRoYXQgYmVoYXZpb3IsIHVzZSBXaWR0aFByb3ZpZGVyLlxuICB3aWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy8gSWYgdHJ1ZSwgdGhlIGNvbnRhaW5lciBoZWlnaHQgc3dlbGxzIGFuZCBjb250cmFjdHMgdG8gZml0IGNvbnRlbnRzXG4gIGF1dG9TaXplOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gIyBvZiBjb2xzLlxuICBjb2xzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBBIHNlbGVjdG9yIHRoYXQgd2lsbCBub3QgYmUgZHJhZ2dhYmxlLlxuICBkcmFnZ2FibGVDYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIEEgc2VsZWN0b3IgZm9yIHRoZSBkcmFnZ2FibGUgaGFuZGxlclxuICBkcmFnZ2FibGVIYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIERlcHJlY2F0ZWRcbiAgdmVydGljYWxDb21wYWN0OiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICBpZiAocHJvcHMudmVydGljYWxDb21wYWN0ID09PSBmYWxzZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgXCJgdmVydGljYWxDb21wYWN0YCBvbiA8UmVhY3RHcmlkTGF5b3V0PiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gXCIgKyAnVXNlIGBjb21wYWN0VHlwZWA6IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiIHwgbnVsbC4nKTtcbiAgICB9XG4gIH0sXG4gIC8vIENob29zZSB2ZXJ0aWNhbCBvciBob3Rpem9udGFsIGNvbXBhY3Rpb25cbiAgY29tcGFjdFR5cGU6IChfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCJdKSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBsYXlvdXQgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHdpdGggdGhlIGZvcm1hdDpcbiAgLy8ge3g6IE51bWJlciwgeTogTnVtYmVyLCB3OiBOdW1iZXIsIGg6IE51bWJlciwgaTogU3RyaW5nfVxuICBsYXlvdXQ6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLykge1xuICAgIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgLy8gSSBob3BlIHlvdSdyZSBzZXR0aW5nIHRoZSBkYXRhLWdyaWQgcHJvcGVydHkgb24gdGhlIGdyaWQgaXRlbXNcbiAgICBpZiAobGF5b3V0ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICByZXF1aXJlKFwiLi91dGlsc1wiKS52YWxpZGF0ZUxheW91dChsYXlvdXQsIFwibGF5b3V0XCIpO1xuICB9LFxuICAvL1xuICAvLyBHcmlkIERpbWVuc2lvbnNcbiAgLy9cblxuICAvLyBNYXJnaW4gYmV0d2VlbiBpdGVtcyBbeCwgeV0gaW4gcHhcbiAgbWFyZ2luOiAoX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcikgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovKSxcbiAgLy8gUGFkZGluZyBpbnNpZGUgdGhlIGNvbnRhaW5lciBbeCwgeV0gaW4gcHhcbiAgY29udGFpbmVyUGFkZGluZzogKF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIpIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyksXG4gIC8vIFJvd3MgaGF2ZSBhIHN0YXRpYyBoZWlnaHQsIGJ1dCB5b3UgY2FuIGNoYW5nZSB0aGlzIGJhc2VkIG9uIGJyZWFrcG9pbnRzIGlmIHlvdSBsaWtlXG4gIHJvd0hlaWdodDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy8gRGVmYXVsdCBJbmZpbml0eSwgYnV0IHlvdSBjYW4gc3BlY2lmeSBhIG1heCBoZXJlIGlmIHlvdSBsaWtlLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBpc24ndCBmdWxseSBmbGVzaGVkIG91dCBhbmQgd29uJ3QgZXJyb3IgaWYgeW91IHNwZWNpZnkgYSBsYXlvdXQgdGhhdFxuICAvLyBleHRlbmRzIGJleW9uZCB0aGUgcm93IGNhcGFjaXR5LiBJdCB3aWxsLCBob3dldmVyLCBub3QgYWxsb3cgdXNlcnMgdG8gZHJhZy9yZXNpemVcbiAgLy8gYW4gaXRlbSBwYXN0IHRoZSBiYXJyaWVyLiBUaGV5IGNhbiBwdXNoIGl0ZW1zIGJleW9uZCB0aGUgYmFycmllciwgdGhvdWdoLlxuICAvLyBJbnRlbnRpb25hbGx5IG5vdCBkb2N1bWVudGVkIGZvciB0aGlzIHJlYXNvbi5cbiAgbWF4Um93czogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy9cbiAgLy8gRmxhZ3NcbiAgLy9cbiAgaXNCb3VuZGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgaXNEcmFnZ2FibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBpc1Jlc2l6YWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIElmIHRydWUsIGdyaWQgY2FuIGJlIHBsYWNlZCBvbmUgb3ZlciB0aGUgb3RoZXIuXG4gIGFsbG93T3ZlcmxhcDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIElmIHRydWUsIGdyaWQgaXRlbXMgd29uJ3QgY2hhbmdlIHBvc2l0aW9uIHdoZW4gYmVpbmcgZHJhZ2dlZCBvdmVyLlxuICBwcmV2ZW50Q29sbGlzaW9uOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gVXNlIENTUyB0cmFuc2Zvcm1zIGluc3RlYWQgb2YgdG9wL2xlZnRcbiAgdXNlQ1NTVHJhbnNmb3JtczogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIHBhcmVudCBsYXlvdXQgdHJhbnNmb3JtIHNjYWxlXG4gIHRyYW5zZm9ybVNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBJZiB0cnVlLCBhbiBleHRlcm5hbCBlbGVtZW50IGNhbiB0cmlnZ2VyIG9uRHJvcCBjYWxsYmFjayB3aXRoIGEgc3BlY2lmaWMgZ3JpZCBwb3NpdGlvbiBhcyBhIHBhcmFtZXRlclxuICBpc0Ryb3BwYWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8vIFJlc2l6ZSBoYW5kbGUgb3B0aW9uc1xuICByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVBeGVzVHlwZSxcbiAgcmVzaXplSGFuZGxlOiByZXNpemVIYW5kbGVUeXBlLFxuICAvL1xuICAvLyBDYWxsYmFja3NcbiAgLy9cblxuICAvLyBDYWxsYmFjayBzbyB5b3UgY2FuIHNhdmUgdGhlIGxheW91dC4gQ2FsbHMgYWZ0ZXIgZWFjaCBkcmFnICYgcmVzaXplIHN0b3BzLlxuICBvbkxheW91dENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gZHJhZyBzdGFydHMuIENhbGxiYWNrIGlzIG9mIHRoZSBzaWduYXR1cmUgKGxheW91dCwgb2xkSXRlbSwgbmV3SXRlbSwgcGxhY2Vob2xkZXIsIGUsID9ub2RlKS5cbiAgLy8gQWxsIGNhbGxiYWNrcyBiZWxvdyBoYXZlIHRoZSBzYW1lIHNpZ25hdHVyZS4gJ3N0YXJ0JyBhbmQgJ3N0b3AnIGNhbGxiYWNrcyBvbWl0IHRoZSAncGxhY2Vob2xkZXInLlxuICBvbkRyYWdTdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIG9uIGVhY2ggZHJhZyBtb3ZlbWVudC5cbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiBkcmFnIGlzIGNvbXBsZXRlLlxuICBvbkRyYWdTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy9DYWxscyB3aGVuIHJlc2l6ZSBzdGFydHMuXG4gIG9uUmVzaXplU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIHJlc2l6ZSBtb3ZlbWVudCBoYXBwZW5zLlxuICBvblJlc2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gcmVzaXplIGlzIGNvbXBsZXRlLlxuICBvblJlc2l6ZVN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIHNvbWUgZWxlbWVudCBpcyBkcm9wcGVkLlxuICBvbkRyb3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvL1xuICAvLyBPdGhlciB2YWxpZGF0aW9uc1xuICAvL1xuXG4gIGRyb3BwaW5nSXRlbTogKF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgaTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHc6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWRcbiAgfSkgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovKSxcbiAgLy8gQ2hpbGRyZW4gbXVzdCBub3QgaGF2ZSBkdXBsaWNhdGUga2V5cy5cbiAgY2hpbGRyZW46IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wc1twcm9wTmFtZV07XG5cbiAgICAvLyBDaGVjayBjaGlsZHJlbiBrZXlzIGZvciBkdXBsaWNhdGVzLiBUaHJvdyBpZiBmb3VuZC5cbiAgICBjb25zdCBrZXlzID0ge307XG4gICAgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQ/LmtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAoa2V5c1tjaGlsZC5rZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIGNoaWxkIGtleSBcIicgKyBjaGlsZC5rZXkgKyAnXCIgZm91bmQhIFRoaXMgd2lsbCBjYXVzZSBwcm9ibGVtcyBpbiBSZWFjdEdyaWRMYXlvdXQuJyk7XG4gICAgICB9XG4gICAgICBrZXlzW2NoaWxkLmtleV0gPSB0cnVlO1xuICAgIH0pO1xuICB9LFxuICAvLyBPcHRpb25hbCByZWYgZm9yIGdldHRpbmcgYSByZWZlcmVuY2UgZm9yIHRoZSB3cmFwcGluZyBkaXYuXG4gIGlubmVyUmVmOiBfcHJvcFR5cGVzLmRlZmF1bHQuYW55XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _responsiveUtils = __webpack_require__(/*! ./responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nvar _ReactGridLayout = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*:: import { type Layout, type Pick } from \"./utils\";*/ /*:: import { type ResponsiveLayout, type OnLayoutChangeCallback, type Breakpoints } from \"./responsiveUtils\";*/\n// $FlowFixMe[method-unbinding]\nconst type = obj => Object.prototype.toString.call(obj);\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\nfunction getIndentationValue /*:: <T: ?[number, number]>*/(param /*: { [key: string]: T } | T*/, breakpoint /*: string*/) /*: T*/{\n  // $FlowIgnore TODO fix this typedef\n  if (param == null) return null;\n  // $FlowIgnore TODO fix this typedef\n  return Array.isArray(param) ? param : param[breakpoint];\n}\n/*:: type State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: ResponsiveLayout<string>\n};*/\n/*:: type Props<Breakpoint: string = string> = {|\n  ...React.ElementConfig<typeof ReactGridLayout>,\n\n  // Responsive config\n  breakpoint?: ?Breakpoint,\n  breakpoints: Breakpoints<Breakpoint>,\n  cols: { [key: Breakpoint]: number },\n  layouts: ResponsiveLayout<Breakpoint>,\n  width: number,\n  margin: { [key: Breakpoint]: [number, number] } | [number, number],\n  /* prettier-ignore *-/\n  containerPadding: { [key: Breakpoint]: ?[number, number] } | ?[number, number],\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: OnLayoutChangeCallback,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: ?[number, number]\n  ) => void\n|};*/\n/*:: type DefaultProps = Pick<\n  Props<>,\n  {|\n    allowOverlap: 0,\n    breakpoints: 0,\n    cols: 0,\n    containerPadding: 0,\n    layouts: 0,\n    margin: 0,\n    onBreakpointChange: 0,\n    onLayoutChange: 0,\n    onWidthChange: 0\n  |}\n>;*/\nclass ResponsiveReactGridLayout extends React.Component\n/*:: <\n  Props<>,\n  State\n>*/\n{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", this.generateInitialState());\n    // wrap layouts so we do not need to pass layouts to child\n    _defineProperty(this, \"onLayoutChange\", (layout /*: Layout*/) => {\n      this.props.onLayoutChange(layout, {\n        ...this.props.layouts,\n        [this.state.breakpoint]: layout\n      });\n    });\n  }\n  generateInitialState() /*: State*/{\n    const {\n      width,\n      breakpoints,\n      layouts,\n      cols\n    } = this.props;\n    const breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n    const colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType = this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    const initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n  static getDerivedStateFromProps(nextProps /*: Props<*>*/, prevState /*: State*/) /*: ?$Shape<State>*/{\n    if (!(0, _fastEquals.deepEqual)(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const {\n        breakpoint,\n        cols\n      } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, cols, nextProps.compactType);\n      return {\n        layout: newLayout,\n        layouts: nextProps.layouts\n      };\n    }\n    return null;\n  }\n  componentDidUpdate(prevProps /*: Props<*>*/) {\n    // Allow parent to set width or breakpoint directly.\n    if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _fastEquals.deepEqual)(this.props.breakpoints, prevProps.breakpoints) || !(0, _fastEquals.deepEqual)(this.props.cols, prevProps.cols)) {\n      this.onWidthChange(prevProps);\n    }\n  }\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(prevProps /*: Props<*>*/) {\n    const {\n      breakpoints,\n      cols,\n      layouts,\n      compactType\n    } = this.props;\n    const newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols /*: number*/ = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n    const newLayouts = {\n      ...layouts\n    };\n\n    // Breakpoint change\n    if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in newLayouts)) newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);\n\n      // This adds missing items.\n      layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);\n\n      // Store the new layout.\n      newLayouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n      this.props.onLayoutChange(layout, newLayouts);\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n    const margin = getIndentationValue(this.props.margin, newBreakpoint);\n    const containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);\n\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);\n  }\n  render() /*: React.Element<typeof ReactGridLayout>*/{\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      margin,\n      containerPadding,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n\n    return /*#__PURE__*/React.createElement(_ReactGridLayout.default, _extends({}, other, {\n      // $FlowIgnore should allow nullable here due to DefaultProps\n      margin: getIndentationValue(margin, this.state.breakpoint),\n      containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),\n      onLayoutChange: this.onLayoutChange,\n      layout: this.state.layout,\n      cols: this.state.cols\n    }));\n  }\n}\nexports[\"default\"] = ResponsiveReactGridLayout;\n// This should only include propTypes needed in this code; RGL itself\n// will do validation of the rest props passed to it.\n_defineProperty(ResponsiveReactGridLayout, \"propTypes\", {\n  //\n  // Basic props\n  //\n\n  // Optional, but if you are managing width yourself you may want to set the breakpoint\n  // yourself as well.\n  breakpoint: _propTypes.default.string,\n  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n  breakpoints: _propTypes.default.object,\n  allowOverlap: _propTypes.default.bool,\n  // # of cols. This is a breakpoint -> cols map\n  cols: _propTypes.default.object,\n  // # of margin. This is a breakpoint -> margin map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Margin between items [x, y] in px\n  // e.g. [10, 10]\n  margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // # of containerPadding. This is a breakpoint -> containerPadding map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Padding inside the container [x, y] in px\n  // e.g. [10, 10]\n  containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // layouts is an object mapping breakpoints to layouts.\n  // e.g. {lg: Layout, md: Layout, ...}\n  layouts(props /*: Props<>*/, propName /*: string*/) {\n    if (type(props[propName]) !== \"[object Object]\") {\n      throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n    }\n    Object.keys(props[propName]).forEach(key => {\n      if (!(key in props.breakpoints)) {\n        throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n      }\n      (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n    });\n  },\n  // The width of this component.\n  // Required in this propTypes stanza because generateInitialState() will fail without it.\n  width: _propTypes.default.number.isRequired,\n  //\n  // Callbacks\n  //\n\n  // Calls back with breakpoint and new # cols\n  onBreakpointChange: _propTypes.default.func,\n  // Callback so you can save the layout.\n  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n  onLayoutChange: _propTypes.default.func,\n  // Calls back with (containerWidth, margin, cols, containerPadding)\n  onWidthChange: _propTypes.default.func\n});\n_defineProperty(ResponsiveReactGridLayout, \"defaultProps\", {\n  breakpoints: {\n    lg: 1200,\n    md: 996,\n    sm: 768,\n    xs: 480,\n    xxs: 0\n  },\n  cols: {\n    lg: 12,\n    md: 10,\n    sm: 6,\n    xs: 4,\n    xxs: 2\n  },\n  containerPadding: {\n    lg: null,\n    md: null,\n    sm: null,\n    xs: null,\n    xxs: null\n  },\n  layouts: {},\n  margin: [10, 10],\n  allowOverlap: false,\n  onBreakpointChange: _utils.noop,\n  onLayoutChange: _utils.noop,\n  onWidthChange: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5Qix1QkFBdUIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDbEQsOENBQThDLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3pFLHVDQUF1Qyx1Q0FBdUM7QUFDOUUsdUNBQXVDLCtDQUErQywwQ0FBMEMsa0RBQWtELG1CQUFtQjtBQUNyTSx5Q0FBeUMsdUNBQXVDLDJFQUEyRSxjQUFjLHFDQUFxQyxvQ0FBb0MsVUFBVSxpQkFBaUIsZ0VBQWdFLHNGQUFzRiwwREFBMEQsd0VBQXdFO0FBQ3JpQixzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RSx1REFBdUQsY0FBYyx5QkFBeUIsZUFBZSxpQkFBaUIsdUVBQXVFLHlCQUF5QjtBQUNqaUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixrREFBa0Qsa0JBQWtCO0FBQ2hHLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQSx1RUFBdUUsbUJBQW1CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSxzQkFBc0IsdUNBQXVDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVksUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlbWl1bS1iZW50by1ncmlkLWVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LmpzPzQyZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfcmVzcG9uc2l2ZVV0aWxzID0gcmVxdWlyZShcIi4vcmVzcG9uc2l2ZVV0aWxzXCIpO1xudmFyIF9SZWFjdEdyaWRMYXlvdXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWN0R3JpZExheW91dFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuLmRlZmF1bHQgPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH0gLyo6OiBpbXBvcnQgeyB0eXBlIExheW91dCwgdHlwZSBQaWNrIH0gZnJvbSBcIi4vdXRpbHNcIjsqLyAvKjo6IGltcG9ydCB7IHR5cGUgUmVzcG9uc2l2ZUxheW91dCwgdHlwZSBPbkxheW91dENoYW5nZUNhbGxiYWNrLCB0eXBlIEJyZWFrcG9pbnRzIH0gZnJvbSBcIi4vcmVzcG9uc2l2ZVV0aWxzXCI7Ki9cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbmNvbnN0IHR5cGUgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbi8qKlxuICogR2V0IGEgdmFsdWUgb2YgbWFyZ2luIG9yIGNvbnRhaW5lclBhZGRpbmcuXG4gKlxuICogQHBhcmFtICB7QXJyYXkgfCBPYmplY3R9IHBhcmFtIE1hcmdpbiB8IGNvbnRhaW5lclBhZGRpbmcsIGUuZy4gWzEwLCAxMF0gfCB7bGc6IFsxMCwgMTBdLCAuLi59LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgQnJlYWtwb2ludDogbGcsIG1kLCBzbSwgeHMgYW5kIGV0Yy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvblZhbHVlIC8qOjogPFQ6ID9bbnVtYmVyLCBudW1iZXJdPiovKHBhcmFtIC8qOiB7IFtrZXk6IHN0cmluZ106IFQgfSB8IFQqLywgYnJlYWtwb2ludCAvKjogc3RyaW5nKi8pIC8qOiBUKi97XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICBpZiAocGFyYW0gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJhbSkgPyBwYXJhbSA6IHBhcmFtW2JyZWFrcG9pbnRdO1xufVxuLyo6OiB0eXBlIFN0YXRlID0ge1xuICBsYXlvdXQ6IExheW91dCxcbiAgYnJlYWtwb2ludDogc3RyaW5nLFxuICBjb2xzOiBudW1iZXIsXG4gIGxheW91dHM/OiBSZXNwb25zaXZlTGF5b3V0PHN0cmluZz5cbn07Ki9cbi8qOjogdHlwZSBQcm9wczxCcmVha3BvaW50OiBzdHJpbmcgPSBzdHJpbmc+ID0ge3xcbiAgLi4uUmVhY3QuRWxlbWVudENvbmZpZzx0eXBlb2YgUmVhY3RHcmlkTGF5b3V0PixcblxuICAvLyBSZXNwb25zaXZlIGNvbmZpZ1xuICBicmVha3BvaW50PzogP0JyZWFrcG9pbnQsXG4gIGJyZWFrcG9pbnRzOiBCcmVha3BvaW50czxCcmVha3BvaW50PixcbiAgY29sczogeyBba2V5OiBCcmVha3BvaW50XTogbnVtYmVyIH0sXG4gIGxheW91dHM6IFJlc3BvbnNpdmVMYXlvdXQ8QnJlYWtwb2ludD4sXG4gIHdpZHRoOiBudW1iZXIsXG4gIG1hcmdpbjogeyBba2V5OiBCcmVha3BvaW50XTogW251bWJlciwgbnVtYmVyXSB9IHwgW251bWJlciwgbnVtYmVyXSxcbiAgLyogcHJldHRpZXItaWdub3JlICotL1xuICBjb250YWluZXJQYWRkaW5nOiB7IFtrZXk6IEJyZWFrcG9pbnRdOiA/W251bWJlciwgbnVtYmVyXSB9IHwgP1tudW1iZXIsIG51bWJlcl0sXG5cbiAgLy8gQ2FsbGJhY2tzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogKEJyZWFrcG9pbnQsIGNvbHM6IG51bWJlcikgPT4gdm9pZCxcbiAgb25MYXlvdXRDaGFuZ2U6IE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2ssXG4gIG9uV2lkdGhDaGFuZ2U6IChcbiAgICBjb250YWluZXJXaWR0aDogbnVtYmVyLFxuICAgIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgICBjb2xzOiBudW1iZXIsXG4gICAgY29udGFpbmVyUGFkZGluZzogP1tudW1iZXIsIG51bWJlcl1cbiAgKSA9PiB2b2lkXG58fTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IFBpY2s8XG4gIFByb3BzPD4sXG4gIHt8XG4gICAgYWxsb3dPdmVybGFwOiAwLFxuICAgIGJyZWFrcG9pbnRzOiAwLFxuICAgIGNvbHM6IDAsXG4gICAgY29udGFpbmVyUGFkZGluZzogMCxcbiAgICBsYXlvdXRzOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBvbkJyZWFrcG9pbnRDaGFuZ2U6IDAsXG4gICAgb25MYXlvdXRDaGFuZ2U6IDAsXG4gICAgb25XaWR0aENoYW5nZTogMFxuICB8fVxuPjsqL1xuY2xhc3MgUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuLyo6OiA8XG4gIFByb3BzPD4sXG4gIFN0YXRlXG4+Ki9cbntcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB0aGlzLmdlbmVyYXRlSW5pdGlhbFN0YXRlKCkpO1xuICAgIC8vIHdyYXAgbGF5b3V0cyBzbyB3ZSBkbyBub3QgbmVlZCB0byBwYXNzIGxheW91dHMgdG8gY2hpbGRcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkxheW91dENoYW5nZVwiLCAobGF5b3V0IC8qOiBMYXlvdXQqLykgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkxheW91dENoYW5nZShsYXlvdXQsIHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5sYXlvdXRzLFxuICAgICAgICBbdGhpcy5zdGF0ZS5icmVha3BvaW50XTogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZUluaXRpYWxTdGF0ZSgpIC8qOiBTdGF0ZSove1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBsYXlvdXRzLFxuICAgICAgY29sc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKShicmVha3BvaW50cywgd2lkdGgpO1xuICAgIGNvbnN0IGNvbE5vID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZ2V0Q29sc0Zyb21CcmVha3BvaW50KShicmVha3BvaW50LCBjb2xzKTtcbiAgICAvLyB2ZXJ0aWNhbENvbXBhY3QgY29tcGF0aWJpbGl0eSwgbm93IGRlcHJlY2F0ZWRcbiAgICBjb25zdCBjb21wYWN0VHlwZSA9IHRoaXMucHJvcHMudmVydGljYWxDb21wYWN0ID09PSBmYWxzZSA/IG51bGwgOiB0aGlzLnByb3BzLmNvbXBhY3RUeXBlO1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQuIFRoaXMgY2FuIHRyaWNreTsgd2UgdHJ5IHRvIGdlbmVyYXRlIG9uZSBob3dldmVyIHBvc3NpYmxlIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgLy8gZm9yIHRoaXMgbGF5b3V0LlxuICAgIGNvbnN0IGluaXRpYWxMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKGxheW91dHMsIGJyZWFrcG9pbnRzLCBicmVha3BvaW50LCBicmVha3BvaW50LCBjb2xObywgY29tcGFjdFR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYXlvdXQ6IGluaXRpYWxMYXlvdXQsXG4gICAgICBicmVha3BvaW50OiBicmVha3BvaW50LFxuICAgICAgY29sczogY29sTm9cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzIC8qOiBQcm9wczwqPiovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIC8qOiA/JFNoYXBlPFN0YXRlPiove1xuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkobmV4dFByb3BzLmxheW91dHMsIHByZXZTdGF0ZS5sYXlvdXRzKSkge1xuICAgICAgLy8gQWxsb3cgcGFyZW50IHRvIHNldCBsYXlvdXRzIGRpcmVjdGx5LlxuICAgICAgY29uc3Qge1xuICAgICAgICBicmVha3BvaW50LFxuICAgICAgICBjb2xzXG4gICAgICB9ID0gcHJldlN0YXRlO1xuXG4gICAgICAvLyBTaW5jZSB3ZSdyZSBzZXR0aW5nIGFuIGVudGlyZWx5IG5ldyBsYXlvdXQgb2JqZWN0LCB3ZSBtdXN0IGdlbmVyYXRlIGEgbmV3IHJlc3BvbnNpdmUgbGF5b3V0XG4gICAgICAvLyBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKG5leHRQcm9wcy5sYXlvdXRzLCBuZXh0UHJvcHMuYnJlYWtwb2ludHMsIGJyZWFrcG9pbnQsIGJyZWFrcG9pbnQsIGNvbHMsIG5leHRQcm9wcy5jb21wYWN0VHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgbGF5b3V0czogbmV4dFByb3BzLmxheW91dHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMgLyo6IFByb3BzPCo+Ki8pIHtcbiAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IHdpZHRoIG9yIGJyZWFrcG9pbnQgZGlyZWN0bHkuXG4gICAgaWYgKHRoaXMucHJvcHMud2lkdGggIT0gcHJldlByb3BzLndpZHRoIHx8IHRoaXMucHJvcHMuYnJlYWtwb2ludCAhPT0gcHJldlByb3BzLmJyZWFrcG9pbnQgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuYnJlYWtwb2ludHMsIHByZXZQcm9wcy5icmVha3BvaW50cykgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuY29scywgcHJldlByb3BzLmNvbHMpKSB7XG4gICAgICB0aGlzLm9uV2lkdGhDaGFuZ2UocHJldlByb3BzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpZHRoIGNoYW5nZXMgd29yayB0aHJvdWdoIGJyZWFrcG9pbnRzIGFuZCByZXNldCBzdGF0ZSB3aXRoIHRoZSBuZXcgd2lkdGggJiBicmVha3BvaW50LlxuICAgKiBXaWR0aCBjaGFuZ2VzIGFyZSBuZWNlc3NhcnkgdG8gZmlndXJlIG91dCB0aGUgd2lkZ2V0IHdpZHRocy5cbiAgICovXG4gIG9uV2lkdGhDaGFuZ2UocHJldlByb3BzIC8qOiBQcm9wczwqPiovKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIGNvbXBhY3RUeXBlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbmV3QnJlYWtwb2ludCA9IHRoaXMucHJvcHMuYnJlYWtwb2ludCB8fCAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKSh0aGlzLnByb3BzLmJyZWFrcG9pbnRzLCB0aGlzLnByb3BzLndpZHRoKTtcbiAgICBjb25zdCBsYXN0QnJlYWtwb2ludCA9IHRoaXMuc3RhdGUuYnJlYWtwb2ludDtcbiAgICBjb25zdCBuZXdDb2xzIC8qOiBudW1iZXIqLyA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmdldENvbHNGcm9tQnJlYWtwb2ludCkobmV3QnJlYWtwb2ludCwgY29scyk7XG4gICAgY29uc3QgbmV3TGF5b3V0cyA9IHtcbiAgICAgIC4uLmxheW91dHNcbiAgICB9O1xuXG4gICAgLy8gQnJlYWtwb2ludCBjaGFuZ2VcbiAgICBpZiAobGFzdEJyZWFrcG9pbnQgIT09IG5ld0JyZWFrcG9pbnQgfHwgcHJldlByb3BzLmJyZWFrcG9pbnRzICE9PSBicmVha3BvaW50cyB8fCBwcmV2UHJvcHMuY29scyAhPT0gY29scykge1xuICAgICAgLy8gUHJlc2VydmUgdGhlIGN1cnJlbnQgbGF5b3V0IGlmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgbGF5b3V0cy5cbiAgICAgIGlmICghKGxhc3RCcmVha3BvaW50IGluIG5ld0xheW91dHMpKSBuZXdMYXlvdXRzW2xhc3RCcmVha3BvaW50XSA9ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKHRoaXMuc3RhdGUubGF5b3V0KTtcblxuICAgICAgLy8gRmluZCBvciBnZW5lcmF0ZSBhIG5ldyBsYXlvdXQuXG4gICAgICBsZXQgbGF5b3V0ID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KShuZXdMYXlvdXRzLCBicmVha3BvaW50cywgbmV3QnJlYWtwb2ludCwgbGFzdEJyZWFrcG9pbnQsIG5ld0NvbHMsIGNvbXBhY3RUeXBlKTtcblxuICAgICAgLy8gVGhpcyBhZGRzIG1pc3NpbmcgaXRlbXMuXG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLnN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKShsYXlvdXQsIHRoaXMucHJvcHMuY2hpbGRyZW4sIG5ld0NvbHMsIGNvbXBhY3RUeXBlLCB0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgbmV3TGF5b3V0c1tuZXdCcmVha3BvaW50XSA9IGxheW91dDtcblxuICAgICAgLy8gY2FsbGJhY2tzXG4gICAgICB0aGlzLnByb3BzLm9uQnJlYWtwb2ludENoYW5nZShuZXdCcmVha3BvaW50LCBuZXdDb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25MYXlvdXRDaGFuZ2UobGF5b3V0LCBuZXdMYXlvdXRzKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBicmVha3BvaW50OiBuZXdCcmVha3BvaW50LFxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgY29sczogbmV3Q29sc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcmdpbiA9IGdldEluZGVudGF0aW9uVmFsdWUodGhpcy5wcm9wcy5tYXJnaW4sIG5ld0JyZWFrcG9pbnQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRJbmRlbnRhdGlvblZhbHVlKHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZywgbmV3QnJlYWtwb2ludCk7XG5cbiAgICAvL2NhbGwgb25XaWR0aENoYW5nZSBvbiBldmVyeSBjaGFuZ2Ugb2Ygd2lkdGgsIG5vdCBvbmx5IG9uIGJyZWFrcG9pbnQgY2hhbmdlc1xuICAgIHRoaXMucHJvcHMub25XaWR0aENoYW5nZSh0aGlzLnByb3BzLndpZHRoLCBtYXJnaW4sIG5ld0NvbHMsIGNvbnRhaW5lclBhZGRpbmcpO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdC5FbGVtZW50PHR5cGVvZiBSZWFjdEdyaWRMYXlvdXQ+Ki97XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCB7XG4gICAgICBicmVha3BvaW50LFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICBvbkJyZWFrcG9pbnRDaGFuZ2UsXG4gICAgICBvbkxheW91dENoYW5nZSxcbiAgICAgIG9uV2lkdGhDaGFuZ2UsXG4gICAgICAuLi5vdGhlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfUmVhY3RHcmlkTGF5b3V0LmRlZmF1bHQsIF9leHRlbmRzKHt9LCBvdGhlciwge1xuICAgICAgLy8gJEZsb3dJZ25vcmUgc2hvdWxkIGFsbG93IG51bGxhYmxlIGhlcmUgZHVlIHRvIERlZmF1bHRQcm9wc1xuICAgICAgbWFyZ2luOiBnZXRJbmRlbnRhdGlvblZhbHVlKG1hcmdpbiwgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGdldEluZGVudGF0aW9uVmFsdWUoY29udGFpbmVyUGFkZGluZywgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIG9uTGF5b3V0Q2hhbmdlOiB0aGlzLm9uTGF5b3V0Q2hhbmdlLFxuICAgICAgbGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgIGNvbHM6IHRoaXMuc3RhdGUuY29sc1xuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dDtcbi8vIFRoaXMgc2hvdWxkIG9ubHkgaW5jbHVkZSBwcm9wVHlwZXMgbmVlZGVkIGluIHRoaXMgY29kZTsgUkdMIGl0c2VsZlxuLy8gd2lsbCBkbyB2YWxpZGF0aW9uIG9mIHRoZSByZXN0IHByb3BzIHBhc3NlZCB0byBpdC5cbl9kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LCBcInByb3BUeXBlc1wiLCB7XG4gIC8vXG4gIC8vIEJhc2ljIHByb3BzXG4gIC8vXG5cbiAgLy8gT3B0aW9uYWwsIGJ1dCBpZiB5b3UgYXJlIG1hbmFnaW5nIHdpZHRoIHlvdXJzZWxmIHlvdSBtYXkgd2FudCB0byBzZXQgdGhlIGJyZWFrcG9pbnRcbiAgLy8geW91cnNlbGYgYXMgd2VsbC5cbiAgYnJlYWtwb2ludDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8ge25hbWU6IHB4VmFsfSwgZS5nLiB7bGc6IDEyMDAsIG1kOiA5OTYsIHNtOiA3NjgsIHhzOiA0ODB9XG4gIGJyZWFrcG9pbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICBhbGxvd092ZXJsYXA6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyAjIG9mIGNvbHMuIFRoaXMgaXMgYSBicmVha3BvaW50IC0+IGNvbHMgbWFwXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIC8vICMgb2YgbWFyZ2luLiBUaGlzIGlzIGEgYnJlYWtwb2ludCAtPiBtYXJnaW4gbWFwXG4gIC8vIGUuZy4geyBsZzogWzUsIDVdLCBtZDogWzEwLCAxMF0sIHNtOiBbMTUsIDE1XSB9XG4gIC8vIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIFt4LCB5XSBpbiBweFxuICAvLyBlLmcuIFsxMCwgMTBdXG4gIG1hcmdpbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5LCBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0XSksXG4gIC8vICMgb2YgY29udGFpbmVyUGFkZGluZy4gVGhpcyBpcyBhIGJyZWFrcG9pbnQgLT4gY29udGFpbmVyUGFkZGluZyBtYXBcbiAgLy8gZS5nLiB7IGxnOiBbNSwgNV0sIG1kOiBbMTAsIDEwXSwgc206IFsxNSwgMTVdIH1cbiAgLy8gUGFkZGluZyBpbnNpZGUgdGhlIGNvbnRhaW5lciBbeCwgeV0gaW4gcHhcbiAgLy8gZS5nLiBbMTAsIDEwXVxuICBjb250YWluZXJQYWRkaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXksIF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RdKSxcbiAgLy8gbGF5b3V0cyBpcyBhbiBvYmplY3QgbWFwcGluZyBicmVha3BvaW50cyB0byBsYXlvdXRzLlxuICAvLyBlLmcuIHtsZzogTGF5b3V0LCBtZDogTGF5b3V0LCAuLi59XG4gIGxheW91dHMocHJvcHMgLyo6IFByb3BzPD4qLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgaWYgKHR5cGUocHJvcHNbcHJvcE5hbWVdKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGF5b3V0IHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIgKyB0eXBlKHByb3BzW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wc1twcm9wTmFtZV0pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghKGtleSBpbiBwcm9wcy5icmVha3BvaW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBrZXkgaW4gbGF5b3V0cyBtdXN0IGFsaWduIHdpdGggYSBrZXkgaW4gYnJlYWtwb2ludHMuXCIpO1xuICAgICAgfVxuICAgICAgKDAsIF91dGlscy52YWxpZGF0ZUxheW91dCkocHJvcHMubGF5b3V0c1trZXldLCBcImxheW91dHMuXCIgKyBrZXkpO1xuICAgIH0pO1xuICB9LFxuICAvLyBUaGUgd2lkdGggb2YgdGhpcyBjb21wb25lbnQuXG4gIC8vIFJlcXVpcmVkIGluIHRoaXMgcHJvcFR5cGVzIHN0YW56YSBiZWNhdXNlIGdlbmVyYXRlSW5pdGlhbFN0YXRlKCkgd2lsbCBmYWlsIHdpdGhvdXQgaXQuXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8vXG4gIC8vIENhbGxiYWNrc1xuICAvL1xuXG4gIC8vIENhbGxzIGJhY2sgd2l0aCBicmVha3BvaW50IGFuZCBuZXcgIyBjb2xzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgbGF5b3V0LlxuICAvLyBDYWxscyBiYWNrIHdpdGggKGN1cnJlbnRMYXlvdXQsIGFsbExheW91dHMpLiBhbGxMYXlvdXRzIGFyZSBrZXllZCBieSBicmVha3BvaW50LlxuICBvbkxheW91dENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIGJhY2sgd2l0aCAoY29udGFpbmVyV2lkdGgsIG1hcmdpbiwgY29scywgY29udGFpbmVyUGFkZGluZylcbiAgb25XaWR0aENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNcbn0pO1xuX2RlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYnJlYWtwb2ludHM6IHtcbiAgICBsZzogMTIwMCxcbiAgICBtZDogOTk2LFxuICAgIHNtOiA3NjgsXG4gICAgeHM6IDQ4MCxcbiAgICB4eHM6IDBcbiAgfSxcbiAgY29sczoge1xuICAgIGxnOiAxMixcbiAgICBtZDogMTAsXG4gICAgc206IDYsXG4gICAgeHM6IDQsXG4gICAgeHhzOiAyXG4gIH0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IHtcbiAgICBsZzogbnVsbCxcbiAgICBtZDogbnVsbCxcbiAgICBzbTogbnVsbCxcbiAgICB4czogbnVsbCxcbiAgICB4eHM6IG51bGxcbiAgfSxcbiAgbGF5b3V0czoge30sXG4gIG1hcmdpbjogWzEwLCAxMF0sXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3V0aWxzLm5vb3AsXG4gIG9uTGF5b3V0Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25XaWR0aENoYW5nZTogX3V0aWxzLm5vb3Bcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/calculateUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY2FsY3VsYXRlVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2IsbUJBQW1CLFdBQVcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLGdJQUFnSSxzQkFBc0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLHlKQUF5SixzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NhbGN1bGF0ZVV0aWxzLmpzP2VmNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbGNHcmlkQ29sV2lkdGggPSBjYWxjR3JpZENvbFdpZHRoO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbiA9IGNhbGNHcmlkSXRlbVBvc2l0aW9uO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1XSFB4ID0gY2FsY0dyaWRJdGVtV0hQeDtcbmV4cG9ydHMuY2FsY1dIID0gY2FsY1dIO1xuZXhwb3J0cy5jYWxjWFkgPSBjYWxjWFk7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG4vKjo6IGltcG9ydCB0eXBlIHsgUG9zaXRpb24gfSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uUGFyYW1zID0ge1xuICBtYXJnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gIGNvbHM6IG51bWJlcixcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlclxufTsqL1xuLy8gSGVscGVyIGZvciBnZW5lcmF0aW5nIGNvbHVtbiB3aWR0aFxuZnVuY3Rpb24gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyAvKjogUG9zaXRpb25QYXJhbXMqLykgLyo6IG51bWJlciove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgY29sc1xuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIHJldHVybiAoY29udGFpbmVyV2lkdGggLSBtYXJnaW5bMF0gKiAoY29scyAtIDEpIC0gY29udGFpbmVyUGFkZGluZ1swXSAqIDIpIC8gY29scztcbn1cblxuLy8gVGhpcyBjYW4gZWl0aGVyIGJlIGNhbGxlZDpcbi8vIGNhbGNHcmlkSXRlbVdIUHgodywgY29sV2lkdGgsIG1hcmdpblswXSlcbi8vIG9yXG4vLyBjYWxjR3JpZEl0ZW1XSFB4KGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKVxuZnVuY3Rpb24gY2FsY0dyaWRJdGVtV0hQeChncmlkVW5pdHMgLyo6IG51bWJlciovLCBjb2xPclJvd1NpemUgLyo6IG51bWJlciovLCBtYXJnaW5QeCAvKjogbnVtYmVyKi8pIC8qOiBudW1iZXIqL3tcbiAgLy8gMCAqIEluZmluaXR5ID09PSBOYU4sIHdoaWNoIGNhdXNlcyBwcm9ibGVtcyB3aXRoIHJlc2l6ZSBjb250cmFpbnRzXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGdyaWRVbml0cykpIHJldHVybiBncmlkVW5pdHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNvbE9yUm93U2l6ZSAqIGdyaWRVbml0cyArIE1hdGgubWF4KDAsIGdyaWRVbml0cyAtIDEpICogbWFyZ2luUHgpO1xufVxuXG4vKipcbiAqIFJldHVybiBwb3NpdGlvbiBvbiB0aGUgcGFnZSBnaXZlbiBhbiB4LCB5LCB3LCBoLlxuICogbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBhbGwgaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7UG9zaXRpb25QYXJhbXN9IHBvc2l0aW9uUGFyYW1zICBQYXJhbWV0ZXJzIG9mIGdyaWQgbmVlZGVkIGZvciBjb29yZGluYXRlcyBjYWxjdWxhdGlvbnMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICB4ICAgICAgICAgICAgICAgICAgICAgIFggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgeSAgICAgICAgICAgICAgICAgICAgICBZIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gIHcgICAgICAgICAgICAgICAgICAgICAgVyBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgICAgICAgICAgICAgICAgIEggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHJldHVybiB7UG9zaXRpb259ICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBjb29yZHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGNHcmlkSXRlbVBvc2l0aW9uKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8sIHcgLyo6IG51bWJlciovLCBoIC8qOiBudW1iZXIqLywgc3RhdGUgLyo6ID9PYmplY3QqLykgLyo6IFBvc2l0aW9uKi97XG4gIGNvbnN0IHtcbiAgICBtYXJnaW4sXG4gICAgY29udGFpbmVyUGFkZGluZyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuICBjb25zdCBvdXQgPSB7fTtcblxuICAvLyBJZiByZXNpemluZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gcmVzaXppbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUucmVzaXppbmcpIHtcbiAgICBvdXQud2lkdGggPSBNYXRoLnJvdW5kKHN0YXRlLnJlc2l6aW5nLndpZHRoKTtcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5yb3VuZChzdGF0ZS5yZXNpemluZy5oZWlnaHQpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY2FsY3VsYXRlIGZyb20gZ3JpZCB1bml0cy5cbiAgZWxzZSB7XG4gICAgb3V0LndpZHRoID0gY2FsY0dyaWRJdGVtV0hQeCh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICBvdXQuaGVpZ2h0ID0gY2FsY0dyaWRJdGVtV0hQeChoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gIH1cblxuICAvLyBJZiBkcmFnZ2luZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gZHJhZ2dpbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy50b3ApO1xuICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy5sZWZ0KTtcbiAgfSBlbHNlIGlmIChzdGF0ZSAmJiBzdGF0ZS5yZXNpemluZyAmJiB0eXBlb2Ygc3RhdGUucmVzaXppbmcudG9wID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzdGF0ZS5yZXNpemluZy5sZWZ0ID09PSBcIm51bWJlclwiKSB7XG4gICAgb3V0LnRvcCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcudG9wKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcubGVmdCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICBlbHNlIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZCgocm93SGVpZ2h0ICsgbWFyZ2luWzFdKSAqIHkgKyBjb250YWluZXJQYWRkaW5nWzFdKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoKGNvbFdpZHRoICsgbWFyZ2luWzBdKSAqIHggKyBjb250YWluZXJQYWRkaW5nWzBdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGZyb20gcGl4ZWxzIHRvIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gdG9wICAgICAgICAgICAgICAgICAgICAgVG9wIHBvc2l0aW9uIChyZWxhdGl2ZSB0byBwYXJlbnQpIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gbGVmdCAgICAgICAgICAgICAgICAgICAgTGVmdCBwb3NpdGlvbiAocmVsYXRpdmUgdG8gcGFyZW50KSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHcgICAgICAgICAgICAgICAgICAgICAgIFcgY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSBoICAgICAgICAgICAgICAgICAgICAgICBIIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgeCBhbmQgeSBpbiBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBjYWxjWFkocG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8sIHRvcCAvKjogbnVtYmVyKi8sIGxlZnQgLyo6IG51bWJlciovLCB3IC8qOiBudW1iZXIqLywgaCAvKjogbnVtYmVyKi8pIC8qOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0qL3tcbiAgY29uc3Qge1xuICAgIG1hcmdpbixcbiAgICBjb250YWluZXJQYWRkaW5nLFxuICAgIGNvbHMsXG4gICAgcm93SGVpZ2h0LFxuICAgIG1heFJvd3NcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIGxlZnQgPSBjb250YWluZXJQYWRkaW5nWCArIHggKiAoY29sV2lkdGggKyBtYXJnaW5YKVxuICAvLyB4ICogKGNvbFdpZHRoICsgbWFyZ2luWCkgPSBsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1hcbiAgLy8geCA9IChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1gpIC8gKGNvbFdpZHRoICsgbWFyZ2luWClcbiAgbGV0IHggPSBNYXRoLnJvdW5kKChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1swXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IHkgPSBNYXRoLnJvdW5kKCh0b3AgLSBjb250YWluZXJQYWRkaW5nWzFdKSAvIChyb3dIZWlnaHQgKyBtYXJnaW5bMV0pKTtcblxuICAvLyBDYXBwaW5nXG4gIHggPSBjbGFtcCh4LCAwLCBjb2xzIC0gdyk7XG4gIHkgPSBjbGFtcCh5LCAwLCBtYXhSb3dzIC0gaCk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGNsdWF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgICAgICAgSGVpZ2h0IGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggICAgICAgICAgICAgICAgICAgV2lkdGggaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgICAgICAgICAgICAgICAgICBYIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0geSAgICAgICAgICAgICAgICAgICAgICAgWSBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlIFJlc2l6ZSBIYW5kbGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgIHcsIGggYXMgZ3JpZCB1bml0cy5cbiAqL1xuZnVuY3Rpb24gY2FsY1dIKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB3aWR0aCAvKjogbnVtYmVyKi8sIGhlaWdodCAvKjogbnVtYmVyKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLywgaGFuZGxlIC8qOiBzdHJpbmcqLykgLyo6IHsgdzogbnVtYmVyLCBoOiBudW1iZXIgfSove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIG1heFJvd3MsXG4gICAgY29scyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIHdpZHRoID0gY29sV2lkdGggKiB3IC0gKG1hcmdpbiAqICh3IC0gMSkpXG4gIC8vIC4uLlxuICAvLyB3ID0gKHdpZHRoICsgbWFyZ2luKSAvIChjb2xXaWR0aCArIG1hcmdpbilcbiAgbGV0IHcgPSBNYXRoLnJvdW5kKCh3aWR0aCArIG1hcmdpblswXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IGggPSBNYXRoLnJvdW5kKChoZWlnaHQgKyBtYXJnaW5bMV0pIC8gKHJvd0hlaWdodCArIG1hcmdpblsxXSkpO1xuXG4gIC8vIENhcHBpbmdcbiAgbGV0IF93ID0gY2xhbXAodywgMCwgY29scyAtIHgpO1xuICBsZXQgX2ggPSBjbGFtcChoLCAwLCBtYXhSb3dzIC0geSk7XG4gIGlmIChbXCJzd1wiLCBcIndcIiwgXCJud1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgX3cgPSBjbGFtcCh3LCAwLCBjb2xzKTtcbiAgfVxuICBpZiAoW1wibndcIiwgXCJuXCIsIFwibmVcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgIF9oID0gY2xhbXAoaCwgMCwgbWF4Um93cyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3OiBfdyxcbiAgICBoOiBfaFxuICB9O1xufVxuXG4vLyBTaW1pbGFyIHRvIF8uY2xhbXBcbmZ1bmN0aW9uIGNsYW1wKG51bSAvKjogbnVtYmVyKi8sIGxvd2VyQm91bmQgLyo6IG51bWJlciovLCB1cHBlckJvdW5kIC8qOiBudW1iZXIqLykgLyo6IG51bWJlciove1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obnVtLCB1cHBlckJvdW5kKSwgbG93ZXJCb3VuZCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/components/WidthProvider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = WidthProvideRGL;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(ssr)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type { ReactRef } from \"../ReactGridLayoutPropTypes\";*/\n/*:: type WPDefaultProps = {|\n  measureBeforeMount: boolean\n|};*/\n/*:: type WPProps = {|\n  className?: string,\n  style?: Object,\n  ...WPDefaultProps\n|};*/\n// eslint-disable-next-line no-unused-vars\n/*:: type WPState = {|\n  width: number\n|};*/\n/*:: type ComposedProps<Config> = {|\n  ...Config,\n  measureBeforeMount?: boolean,\n  className?: string,\n  style?: Object,\n  width?: number\n|};*/\nconst layoutClassName = \"react-grid-layout\";\n\n/*\n * A simple HOC that provides facility for listening to container resizes.\n *\n * The Flow type is pretty janky here. I can't just spread `WPProps` into this returned object - I wish I could - but it triggers\n * a flow bug of some sort that causes it to stop typechecking.\n */\nfunction WidthProvideRGL /*:: <Config>*/(ComposedComponent /*: React.AbstractComponent<Config>*/) /*: React.AbstractComponent<ComposedProps<Config>>*/{\n  var _class;\n  return _class = class WidthProvider extends React.Component\n  /*:: <\n      ComposedProps<Config>,\n      WPState\n    >*/\n  {\n    constructor() {\n      super(...arguments);\n      _defineProperty(this, \"state\", {\n        width: 1280\n      });\n      _defineProperty(this, \"elementRef\", /*#__PURE__*/React.createRef());\n      _defineProperty(this, \"mounted\", false);\n      _defineProperty(this, \"resizeObserver\", void 0);\n    }\n    componentDidMount() {\n      this.mounted = true;\n      this.resizeObserver = new _resizeObserverPolyfill.default(entries => {\n        const node = this.elementRef.current;\n        if (node instanceof HTMLElement) {\n          const width = entries[0].contentRect.width;\n          this.setState({\n            width\n          });\n        }\n      });\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.observe(node);\n      }\n    }\n    componentWillUnmount() {\n      this.mounted = false;\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.unobserve(node);\n      }\n      this.resizeObserver.disconnect();\n    }\n    render() {\n      const {\n        measureBeforeMount,\n        ...rest\n      } = this.props;\n      if (measureBeforeMount && !this.mounted) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: (0, _clsx.default)(this.props.className, layoutClassName),\n          style: this.props.style\n          // $FlowIgnore ref types\n          ,\n          ref: this.elementRef\n        });\n      }\n      return /*#__PURE__*/React.createElement(ComposedComponent, _extends({\n        innerRef: this.elementRef\n      }, rest, this.state));\n    }\n  }, _defineProperty(_class, \"defaultProps\", {\n    measureBeforeMount: false\n  }), _defineProperty(_class, \"propTypes\", {\n    // If true, will not render children until mounted. Useful for getting the exact width before\n    // rendering, to prevent any unsightly resizing.\n    measureBeforeMount: _propTypes.default.bool\n  }), _class;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsd0NBQXdDLG1CQUFPLENBQUMsNERBQVk7QUFDNUQscURBQXFELG1CQUFPLENBQUMseUdBQTBCO0FBQ3ZGLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHVDQUF1Qyx1Q0FBdUM7QUFDOUUsdUNBQXVDLCtDQUErQywwQ0FBMEMsa0RBQWtELG1CQUFtQjtBQUNyTSx5Q0FBeUMsdUNBQXVDLDJFQUEyRSxjQUFjLHFDQUFxQyxvQ0FBb0MsVUFBVSxpQkFBaUIsZ0VBQWdFLHNGQUFzRiwwREFBMEQsd0VBQXdFO0FBQ3JpQixzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTtBQUNuVSxtQkFBbUIsV0FBVyxtQ0FBbUM7QUFDakUsNEJBQTRCO0FBQzVCO0FBQ0EsR0FBRztBQUNILHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxHQUFHO0FBQ0gsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlci5qcz8wZDc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2lkdGhQcm92aWRlUkdMO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuLmRlZmF1bHQgPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUgeyBSZWFjdFJlZiB9IGZyb20gXCIuLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFdQRGVmYXVsdFByb3BzID0ge3xcbiAgbWVhc3VyZUJlZm9yZU1vdW50OiBib29sZWFuXG58fTsqL1xuLyo6OiB0eXBlIFdQUHJvcHMgPSB7fFxuICBjbGFzc05hbWU/OiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAuLi5XUERlZmF1bHRQcm9wc1xufH07Ki9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLyo6OiB0eXBlIFdQU3RhdGUgPSB7fFxuICB3aWR0aDogbnVtYmVyXG58fTsqL1xuLyo6OiB0eXBlIENvbXBvc2VkUHJvcHM8Q29uZmlnPiA9IHt8XG4gIC4uLkNvbmZpZyxcbiAgbWVhc3VyZUJlZm9yZU1vdW50PzogYm9vbGVhbixcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICBzdHlsZT86IE9iamVjdCxcbiAgd2lkdGg/OiBudW1iZXJcbnx9OyovXG5jb25zdCBsYXlvdXRDbGFzc05hbWUgPSBcInJlYWN0LWdyaWQtbGF5b3V0XCI7XG5cbi8qXG4gKiBBIHNpbXBsZSBIT0MgdGhhdCBwcm92aWRlcyBmYWNpbGl0eSBmb3IgbGlzdGVuaW5nIHRvIGNvbnRhaW5lciByZXNpemVzLlxuICpcbiAqIFRoZSBGbG93IHR5cGUgaXMgcHJldHR5IGphbmt5IGhlcmUuIEkgY2FuJ3QganVzdCBzcHJlYWQgYFdQUHJvcHNgIGludG8gdGhpcyByZXR1cm5lZCBvYmplY3QgLSBJIHdpc2ggSSBjb3VsZCAtIGJ1dCBpdCB0cmlnZ2Vyc1xuICogYSBmbG93IGJ1ZyBvZiBzb21lIHNvcnQgdGhhdCBjYXVzZXMgaXQgdG8gc3RvcCB0eXBlY2hlY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIFdpZHRoUHJvdmlkZVJHTCAvKjo6IDxDb25maWc+Ki8oQ29tcG9zZWRDb21wb25lbnQgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbmZpZz4qLykgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbXBvc2VkUHJvcHM8Q29uZmlnPj4qL3tcbiAgdmFyIF9jbGFzcztcbiAgcmV0dXJuIF9jbGFzcyA9IGNsYXNzIFdpZHRoUHJvdmlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAgLyo6OiA8XG4gICAgICBDb21wb3NlZFByb3BzPENvbmZpZz4sXG4gICAgICBXUFN0YXRlXG4gICAgPiovXG4gIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgIHdpZHRoOiAxMjgwXG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVsZW1lbnRSZWZcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vdW50ZWRcIiwgZmFsc2UpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzaXplT2JzZXJ2ZXJcIiwgdm9pZCAwKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbC5kZWZhdWx0KGVudHJpZXMgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5lbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lYXN1cmVCZWZvcmVNb3VudCxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAobWVhc3VyZUJlZm9yZU1vdW50ICYmICF0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeC5kZWZhdWx0KSh0aGlzLnByb3BzLmNsYXNzTmFtZSwgbGF5b3V0Q2xhc3NOYW1lKSxcbiAgICAgICAgICBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZVxuICAgICAgICAgIC8vICRGbG93SWdub3JlIHJlZiB0eXBlc1xuICAgICAgICAgICxcbiAgICAgICAgICByZWY6IHRoaXMuZWxlbWVudFJlZlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICBpbm5lclJlZjogdGhpcy5lbGVtZW50UmVmXG4gICAgICB9LCByZXN0LCB0aGlzLnN0YXRlKSk7XG4gICAgfVxuICB9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgbWVhc3VyZUJlZm9yZU1vdW50OiBmYWxzZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgXCJwcm9wVHlwZXNcIiwge1xuICAgIC8vIElmIHRydWUsIHdpbGwgbm90IHJlbmRlciBjaGlsZHJlbiB1bnRpbCBtb3VudGVkLiBVc2VmdWwgZm9yIGdldHRpbmcgdGhlIGV4YWN0IHdpZHRoIGJlZm9yZVxuICAgIC8vIHJlbmRlcmluZywgdG8gcHJldmVudCBhbnkgdW5zaWdodGx5IHJlc2l6aW5nLlxuICAgIG1lYXN1cmVCZWZvcmVNb3VudDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2xcbiAgfSksIF9jbGFzcztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/fastRGLPropsEqual.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("// this file was prevaled\nmodule.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {\n  if (a === b) return true;\n  return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvZmFzdFJHTFByb3BzRXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZW1pdW0tYmVudG8tZ3JpZC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvZmFzdFJHTFByb3BzRXF1YWwuanM/M2RjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGZpbGUgd2FzIHByZXZhbGVkXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhc3RSR0xQcm9wc0VxdWFsKGEsIGIsIGlzRXF1YWxJbXBsKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGEuY2xhc3NOYW1lID09PSBiLmNsYXNzTmFtZSAmJiBpc0VxdWFsSW1wbChhLnN0eWxlLCBiLnN0eWxlKSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuYXV0b1NpemUgPT09IGIuYXV0b1NpemUgJiYgYS5jb2xzID09PSBiLmNvbHMgJiYgYS5kcmFnZ2FibGVDYW5jZWwgPT09IGIuZHJhZ2dhYmxlQ2FuY2VsICYmIGEuZHJhZ2dhYmxlSGFuZGxlID09PSBiLmRyYWdnYWJsZUhhbmRsZSAmJiBpc0VxdWFsSW1wbChhLnZlcnRpY2FsQ29tcGFjdCwgYi52ZXJ0aWNhbENvbXBhY3QpICYmIGlzRXF1YWxJbXBsKGEuY29tcGFjdFR5cGUsIGIuY29tcGFjdFR5cGUpICYmIGlzRXF1YWxJbXBsKGEubGF5b3V0LCBiLmxheW91dCkgJiYgaXNFcXVhbEltcGwoYS5tYXJnaW4sIGIubWFyZ2luKSAmJiBpc0VxdWFsSW1wbChhLmNvbnRhaW5lclBhZGRpbmcsIGIuY29udGFpbmVyUGFkZGluZykgJiYgYS5yb3dIZWlnaHQgPT09IGIucm93SGVpZ2h0ICYmIGEubWF4Um93cyA9PT0gYi5tYXhSb3dzICYmIGEuaXNCb3VuZGVkID09PSBiLmlzQm91bmRlZCAmJiBhLmlzRHJhZ2dhYmxlID09PSBiLmlzRHJhZ2dhYmxlICYmIGEuaXNSZXNpemFibGUgPT09IGIuaXNSZXNpemFibGUgJiYgYS5hbGxvd092ZXJsYXAgPT09IGIuYWxsb3dPdmVybGFwICYmIGEucHJldmVudENvbGxpc2lvbiA9PT0gYi5wcmV2ZW50Q29sbGlzaW9uICYmIGEudXNlQ1NTVHJhbnNmb3JtcyA9PT0gYi51c2VDU1NUcmFuc2Zvcm1zICYmIGEudHJhbnNmb3JtU2NhbGUgPT09IGIudHJhbnNmb3JtU2NhbGUgJiYgYS5pc0Ryb3BwYWJsZSA9PT0gYi5pc0Ryb3BwYWJsZSAmJiBpc0VxdWFsSW1wbChhLnJlc2l6ZUhhbmRsZXMsIGIucmVzaXplSGFuZGxlcykgJiYgaXNFcXVhbEltcGwoYS5yZXNpemVIYW5kbGUsIGIucmVzaXplSGFuZGxlKSAmJiBhLm9uTGF5b3V0Q2hhbmdlID09PSBiLm9uTGF5b3V0Q2hhbmdlICYmIGEub25EcmFnU3RhcnQgPT09IGIub25EcmFnU3RhcnQgJiYgYS5vbkRyYWcgPT09IGIub25EcmFnICYmIGEub25EcmFnU3RvcCA9PT0gYi5vbkRyYWdTdG9wICYmIGEub25SZXNpemVTdGFydCA9PT0gYi5vblJlc2l6ZVN0YXJ0ICYmIGEub25SZXNpemUgPT09IGIub25SZXNpemUgJiYgYS5vblJlc2l6ZVN0b3AgPT09IGIub25SZXNpemVTdG9wICYmIGEub25Ecm9wID09PSBiLm9uRHJvcCAmJiBpc0VxdWFsSW1wbChhLmRyb3BwaW5nSXRlbSwgYi5kcm9wcGluZ0l0ZW0pICYmIGlzRXF1YWxJbXBsKGEuaW5uZXJSZWYsIGIuaW5uZXJSZWYpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/responsiveUtils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvcmVzcG9uc2l2ZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHNDQUFzQztBQUN0Qyw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixhQUFhLG1CQUFPLENBQUMsc0VBQVM7QUFDOUIsbUJBQW1CLHNCQUFzQixlQUFlO0FBQ3hELHFDQUFxQztBQUNyQyx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLHNDQUFzQyx1QkFBdUI7QUFDakYsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3Jlc3BvbnNpdmVVdGlscy5qcz81NTJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQgPSBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQ7XG5leHBvcnRzLmdldEJyZWFrcG9pbnRGcm9tV2lkdGggPSBnZXRCcmVha3BvaW50RnJvbVdpZHRoO1xuZXhwb3J0cy5nZXRDb2xzRnJvbUJyZWFrcG9pbnQgPSBnZXRDb2xzRnJvbUJyZWFrcG9pbnQ7XG5leHBvcnRzLnNvcnRCcmVha3BvaW50cyA9IHNvcnRCcmVha3BvaW50cztcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qOjogaW1wb3J0IHR5cGUgeyBDb21wYWN0VHlwZSwgTGF5b3V0IH0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBCcmVha3BvaW50ID0gc3RyaW5nOyovXG4vKjo6IGV4cG9ydCB0eXBlIERlZmF1bHRCcmVha3BvaW50cyA9IFwibGdcIiB8IFwibWRcIiB8IFwic21cIiB8IFwieHNcIiB8IFwieHhzXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVzcG9uc2l2ZUxheW91dDxUOiBCcmVha3BvaW50PiA9IHtcbiAgK1ticmVha3BvaW50OiBUXTogTGF5b3V0XG59OyovXG4vLyArIGluZGljYXRlcyByZWFkLW9ubHlcbi8qOjogZXhwb3J0IHR5cGUgQnJlYWtwb2ludHM8VDogQnJlYWtwb2ludD4gPSB7XG4gICtbYnJlYWtwb2ludDogVF06IG51bWJlclxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBPbkxheW91dENoYW5nZUNhbGxiYWNrID0gKFxuICBMYXlvdXQsXG4gIHsgW2tleTogQnJlYWtwb2ludF06IExheW91dCB9XG4pID0+IHZvaWQ7Ki9cbi8qKlxuICogR2l2ZW4gYSB3aWR0aCwgZmluZCB0aGUgaGlnaGVzdCBicmVha3BvaW50IHRoYXQgbWF0Y2hlcyBpcyB2YWxpZCBmb3IgaXQgKHdpZHRoID4gYnJlYWtwb2ludCkuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBicmVha3BvaW50cyBCcmVha3BvaW50cyBvYmplY3QgKGUuZy4ge2xnOiAxMjAwLCBtZDogOTYwLCAuLi59KVxuICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aCBTY3JlZW4gd2lkdGguXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIEhpZ2hlc3QgYnJlYWtwb2ludCB0aGF0IGlzIGxlc3MgdGhhbiB3aWR0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0QnJlYWtwb2ludEZyb21XaWR0aChicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLywgd2lkdGggLyo6IG51bWJlciovKSAvKjogQnJlYWtwb2ludCove1xuICBjb25zdCBzb3J0ZWQgPSBzb3J0QnJlYWtwb2ludHMoYnJlYWtwb2ludHMpO1xuICBsZXQgbWF0Y2hpbmcgPSBzb3J0ZWRbMF07XG4gIGZvciAobGV0IGkgPSAxLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBicmVha3BvaW50TmFtZSA9IHNvcnRlZFtpXTtcbiAgICBpZiAod2lkdGggPiBicmVha3BvaW50c1ticmVha3BvaW50TmFtZV0pIG1hdGNoaW5nID0gYnJlYWtwb2ludE5hbWU7XG4gIH1cbiAgcmV0dXJuIG1hdGNoaW5nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgYnJlYWtwb2ludCwgZ2V0IHRoZSAjIG9mIGNvbHMgc2V0IGZvciBpdC5cbiAqIEBwYXJhbSAge1N0cmluZ30gYnJlYWtwb2ludCBCcmVha3BvaW50IG5hbWUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbHMgICAgICAgTWFwIG9mIGJyZWFrcG9pbnRzIHRvIGNvbHMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgTnVtYmVyIG9mIGNvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldENvbHNGcm9tQnJlYWtwb2ludChicmVha3BvaW50IC8qOiBCcmVha3BvaW50Ki8sIGNvbHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8pIC8qOiBudW1iZXIqL3tcbiAgaWYgKCFjb2xzW2JyZWFrcG9pbnRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dDogYGNvbHNgIGVudHJ5IGZvciBicmVha3BvaW50IFwiICsgYnJlYWtwb2ludCArIFwiIGlzIG1pc3NpbmchXCIpO1xuICB9XG4gIHJldHVybiBjb2xzW2JyZWFrcG9pbnRdO1xufVxuXG4vKipcbiAqIEdpdmVuIGV4aXN0aW5nIGxheW91dHMgYW5kIGEgbmV3IGJyZWFrcG9pbnQsIGZpbmQgb3IgZ2VuZXJhdGUgYSBuZXcgbGF5b3V0LlxuICpcbiAqIFRoaXMgZmluZHMgdGhlIGxheW91dCBhYm92ZSB0aGUgbmV3IG9uZSBhbmQgZ2VuZXJhdGVzIGZyb20gaXQsIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGxheW91dHMgICAgIEV4aXN0aW5nIGxheW91dHMuXG4gKiBAcGFyYW0gIHtBcnJheX0gYnJlYWtwb2ludHMgQWxsIGJyZWFrcG9pbnRzLlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IE5ldyBicmVha3BvaW50LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IExhc3QgYnJlYWtwb2ludCAoZm9yIGZhbGxiYWNrKS5cbiAqIEBwYXJhbSAge051bWJlcn0gY29scyAgICAgICBDb2x1bW4gY291bnQgYXQgbmV3IGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0XG4gKiAgIHZlcnRpY2FsbHkuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgTmV3IGxheW91dC5cbiAqL1xuZnVuY3Rpb24gZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KGxheW91dHMgLyo6IFJlc3BvbnNpdmVMYXlvdXQ8QnJlYWtwb2ludD4qLywgYnJlYWtwb2ludHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8sIGJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgbGFzdEJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgY29scyAvKjogbnVtYmVyKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovKSAvKjogTGF5b3V0Ki97XG4gIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJldHVybiBpdC5cbiAgaWYgKGxheW91dHNbYnJlYWtwb2ludF0pIHJldHVybiAoMCwgX3V0aWxzLmNsb25lTGF5b3V0KShsYXlvdXRzW2JyZWFrcG9pbnRdKTtcbiAgLy8gRmluZCBvciBnZW5lcmF0ZSB0aGUgbmV4dCBsYXlvdXRcbiAgbGV0IGxheW91dCA9IGxheW91dHNbbGFzdEJyZWFrcG9pbnRdO1xuICBjb25zdCBicmVha3BvaW50c1NvcnRlZCA9IHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gIGNvbnN0IGJyZWFrcG9pbnRzQWJvdmUgPSBicmVha3BvaW50c1NvcnRlZC5zbGljZShicmVha3BvaW50c1NvcnRlZC5pbmRleE9mKGJyZWFrcG9pbnQpKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJyZWFrcG9pbnRzQWJvdmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBiID0gYnJlYWtwb2ludHNBYm92ZVtpXTtcbiAgICBpZiAobGF5b3V0c1tiXSkge1xuICAgICAgbGF5b3V0ID0gbGF5b3V0c1tiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsYXlvdXQgPSAoMCwgX3V0aWxzLmNsb25lTGF5b3V0KShsYXlvdXQgfHwgW10pOyAvLyBjbG9uZSBsYXlvdXQgc28gd2UgZG9uJ3QgbW9kaWZ5IGV4aXN0aW5nIGl0ZW1zXG4gIHJldHVybiAoMCwgX3V0aWxzLmNvbXBhY3QpKCgwLCBfdXRpbHMuY29ycmVjdEJvdW5kcykobGF5b3V0LCB7XG4gICAgY29sczogY29sc1xuICB9KSwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGJyZWFrcG9pbnRzLCByZXR1cm4gYW4gYXJyYXkgb2YgYnJlYWtwb2ludHMgc29ydGVkIGJ5IHdpZHRoLiBUaGlzIGlzIHVzdWFsbHlcbiAqIGUuZy4gWyd4eHMnLCAneHMnLCAnc20nLCAuLi5dXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBicmVha3BvaW50cyBLZXkvdmFsdWUgcGFpciBvZiBicmVha3BvaW50IG5hbWVzIHRvIHdpZHRocy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgU29ydGVkIGJyZWFrcG9pbnRzLlxuICovXG5mdW5jdGlvbiBzb3J0QnJlYWtwb2ludHMoYnJlYWtwb2ludHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8pIC8qOiBBcnJheTxCcmVha3BvaW50Piove1xuICBjb25zdCBrZXlzIC8qOiBBcnJheTxzdHJpbmc+Ki8gPSBPYmplY3Qua2V5cyhicmVha3BvaW50cyk7XG4gIHJldHVybiBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYnJlYWtwb2ludHNbYV0gLSBicmVha3BvaW50c1tiXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-layout/build/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = \"development\" === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = __webpack_require__(/*! ./fastRGLPropsEqual */ \"(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQ0FBb0M7QUFDcEMsWUFBWTtBQUNaLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0Isa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEVBQUUsYUFBYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUMsNEJBQTRCO0FBQ2pFLHNDQUFzQyxzQ0FBc0M7QUFDNUUsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLEVBQUU7QUFDRjtBQUNBLGtDQUFrQztBQUNsQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCLGFBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsa0RBQWtELCtJQUEwRDs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssTUFBTSxVQUFVLEdBQUcsVUFBVSxVQUFVLElBQUksR0FBRyxJQUFJO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0EsdUNBQXVDLEtBQUssTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLGFBQWEsTUFBTSxZQUFZLEdBQUcsWUFBWTs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLHdDQUF3QyxjQUFjLFNBQVMsV0FBVyxHQUFHLFdBQVc7QUFDeEY7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQ0FBaUMsS0FBSyxLQUFLLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLElBQUk7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxHQUFHLEVBQUUsSUFBSSxLQUFLLDhCQUE4QixPQUFPLEdBQUcsYUFBYTtBQUMzSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxHQUFHLEVBQUUsa0NBQWtDLFFBQVEsR0FBRyxjQUFjO0FBQ3RIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlbWl1bS1iZW50by1ncmlkLWVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC91dGlscy5qcz9mZmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ib3R0b20gPSBib3R0b207XG5leHBvcnRzLmNoaWxkcmVuRXF1YWwgPSBjaGlsZHJlbkVxdWFsO1xuZXhwb3J0cy5jbG9uZUxheW91dCA9IGNsb25lTGF5b3V0O1xuZXhwb3J0cy5jbG9uZUxheW91dEl0ZW0gPSBjbG9uZUxheW91dEl0ZW07XG5leHBvcnRzLmNvbGxpZGVzID0gY29sbGlkZXM7XG5leHBvcnRzLmNvbXBhY3QgPSBjb21wYWN0O1xuZXhwb3J0cy5jb21wYWN0SXRlbSA9IGNvbXBhY3RJdGVtO1xuZXhwb3J0cy5jb21wYWN0VHlwZSA9IGNvbXBhY3RUeXBlO1xuZXhwb3J0cy5jb3JyZWN0Qm91bmRzID0gY29ycmVjdEJvdW5kcztcbmV4cG9ydHMuZmFzdFBvc2l0aW9uRXF1YWwgPSBmYXN0UG9zaXRpb25FcXVhbDtcbmV4cG9ydHMuZmFzdFJHTFByb3BzRXF1YWwgPSB2b2lkIDA7XG5leHBvcnRzLmdldEFsbENvbGxpc2lvbnMgPSBnZXRBbGxDb2xsaXNpb25zO1xuZXhwb3J0cy5nZXRGaXJzdENvbGxpc2lvbiA9IGdldEZpcnN0Q29sbGlzaW9uO1xuZXhwb3J0cy5nZXRMYXlvdXRJdGVtID0gZ2V0TGF5b3V0SXRlbTtcbmV4cG9ydHMuZ2V0U3RhdGljcyA9IGdldFN0YXRpY3M7XG5leHBvcnRzLm1vZGlmeUxheW91dCA9IG1vZGlmeUxheW91dDtcbmV4cG9ydHMubW92ZUVsZW1lbnQgPSBtb3ZlRWxlbWVudDtcbmV4cG9ydHMubW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbiA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb247XG5leHBvcnRzLm5vb3AgPSB2b2lkIDA7XG5leHBvcnRzLnBlcmMgPSBwZXJjO1xuZXhwb3J0cy5yZXNpemVJdGVtSW5EaXJlY3Rpb24gPSByZXNpemVJdGVtSW5EaXJlY3Rpb247XG5leHBvcnRzLnNldFRvcExlZnQgPSBzZXRUb3BMZWZ0O1xuZXhwb3J0cy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XG5leHBvcnRzLnNvcnRMYXlvdXRJdGVtcyA9IHNvcnRMYXlvdXRJdGVtcztcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zQnlDb2xSb3cgPSBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdztcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zQnlSb3dDb2wgPSBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbDtcbmV4cG9ydHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4gPSBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbjtcbmV4cG9ydHMudmFsaWRhdGVMYXlvdXQgPSB2YWxpZGF0ZUxheW91dDtcbmV4cG9ydHMud2l0aExheW91dEl0ZW0gPSB3aXRoTGF5b3V0SXRlbTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIENoaWxkcmVuQXJyYXkgYXMgUmVhY3RDaGlsZHJlbkFycmF5LFxuICBFbGVtZW50IGFzIFJlYWN0RWxlbWVudFxufSBmcm9tIFwicmVhY3RcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZXNpemVIYW5kbGVBeGlzID1cbiAgfCBcInNcIlxuICB8IFwid1wiXG4gIHwgXCJlXCJcbiAgfCBcIm5cIlxuICB8IFwic3dcIlxuICB8IFwibndcIlxuICB8IFwic2VcIlxuICB8IFwibmVcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBMYXlvdXRJdGVtID0ge1xuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGk6IHN0cmluZyxcbiAgbWluVz86IG51bWJlcixcbiAgbWluSD86IG51bWJlcixcbiAgbWF4Vz86IG51bWJlcixcbiAgbWF4SD86IG51bWJlcixcbiAgbW92ZWQ/OiBib29sZWFuLFxuICBzdGF0aWM/OiBib29sZWFuLFxuICBpc0RyYWdnYWJsZT86ID9ib29sZWFuLFxuICBpc1Jlc2l6YWJsZT86ID9ib29sZWFuLFxuICByZXNpemVIYW5kbGVzPzogQXJyYXk8UmVzaXplSGFuZGxlQXhpcz4sXG4gIGlzQm91bmRlZD86ID9ib29sZWFuXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIExheW91dCA9ICRSZWFkT25seUFycmF5PExheW91dEl0ZW0+OyovXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge1xuICBsZWZ0OiBudW1iZXIsXG4gIHRvcDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlclxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZWFjdERyYWdnYWJsZUNhbGxiYWNrRGF0YSA9IHtcbiAgbm9kZTogSFRNTEVsZW1lbnQsXG4gIHg/OiBudW1iZXIsXG4gIHk/OiBudW1iZXIsXG4gIGRlbHRhWDogbnVtYmVyLFxuICBkZWx0YVk6IG51bWJlcixcbiAgbGFzdFg/OiBudW1iZXIsXG4gIGxhc3RZPzogbnVtYmVyXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIFBhcnRpYWxQb3NpdGlvbiA9IHsgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciB9OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyb3BwaW5nUG9zaXRpb24gPSB7IGxlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIGU6IEV2ZW50IH07Ki9cbi8qOjogZXhwb3J0IHR5cGUgU2l6ZSA9IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTsqL1xuLyo6OiBleHBvcnQgdHlwZSBHcmlkRHJhZ0V2ZW50ID0ge1xuICBlOiBFdmVudCxcbiAgbm9kZTogSFRNTEVsZW1lbnQsXG4gIG5ld1Bvc2l0aW9uOiBQYXJ0aWFsUG9zaXRpb25cbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgR3JpZFJlc2l6ZUV2ZW50ID0ge1xuICBlOiBFdmVudCxcbiAgbm9kZTogSFRNTEVsZW1lbnQsXG4gIHNpemU6IFNpemUsXG4gIGhhbmRsZTogc3RyaW5nXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdPdmVyRXZlbnQgPSBNb3VzZUV2ZW50ICYge1xuICBuYXRpdmVFdmVudDoge1xuICAgIGxheWVyWDogbnVtYmVyLFxuICAgIGxheWVyWTogbnVtYmVyLFxuICAgIC4uLkV2ZW50XG4gIH1cbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUGljazxGcm9tVHlwZSwgUHJvcGVydGllczogeyBbc3RyaW5nXTogMCB9PiA9ICRFeGFjdDxcbiAgJE9iak1hcGk8UHJvcGVydGllcywgPEssIFY+KGs6IEssIHY6IFYpID0+ICRFbGVtZW50VHlwZTxGcm9tVHlwZSwgSz4+XG4+OyovXG4vLyBIZWxwZnVsIHBvcnQgZnJvbSBUU1xuLyo6OiB0eXBlIFJFbCA9IFJlYWN0RWxlbWVudDxhbnk+OyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlYWN0Q2hpbGRyZW4gPSBSZWFjdENoaWxkcmVuQXJyYXk8UkVsPjsqL1xuLyo6OiBleHBvcnQgdHlwZSBFdmVudENhbGxiYWNrID0gKFxuICBMYXlvdXQsXG4gIG9sZEl0ZW06ID9MYXlvdXRJdGVtLFxuICBuZXdJdGVtOiA/TGF5b3V0SXRlbSxcbiAgcGxhY2Vob2xkZXI6ID9MYXlvdXRJdGVtLFxuICBFdmVudCxcbiAgP0hUTUxFbGVtZW50XG4pID0+IHZvaWQ7Ki9cbi8vIEFsbCBjYWxsYmFja3MgYXJlIG9mIHRoZSBzaWduYXR1cmUgKGxheW91dCwgb2xkSXRlbSwgbmV3SXRlbSwgcGxhY2Vob2xkZXIsIGUpLlxuLyo6OiBleHBvcnQgdHlwZSBDb21wYWN0VHlwZSA9ID8oXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIpOyovXG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG5jb25zdCBERUJVRyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB0aGUgYm90dG9tIGNvb3JkaW5hdGUgb2YgdGhlIGxheW91dC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IExheW91dCBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgQm90dG9tIGNvb3JkaW5hdGUuXG4gKi9cbmZ1bmN0aW9uIGJvdHRvbShsYXlvdXQgLyo6IExheW91dCovKSAvKjogbnVtYmVyKi97XG4gIGxldCBtYXggPSAwLFxuICAgIGJvdHRvbVk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBib3R0b21ZID0gbGF5b3V0W2ldLnkgKyBsYXlvdXRbaV0uaDtcbiAgICBpZiAoYm90dG9tWSA+IG1heCkgbWF4ID0gYm90dG9tWTtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuZnVuY3Rpb24gY2xvbmVMYXlvdXQobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IExheW91dCove1xuICBjb25zdCBuZXdMYXlvdXQgPSBBcnJheShsYXlvdXQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG5ld0xheW91dFtpXSA9IGNsb25lTGF5b3V0SXRlbShsYXlvdXRbaV0pO1xuICB9XG4gIHJldHVybiBuZXdMYXlvdXQ7XG59XG5cbi8vIE1vZGlmeSBhIGxheW91dEl0ZW0gaW5zaWRlIGEgbGF5b3V0LiBSZXR1cm5zIGEgbmV3IExheW91dCxcbi8vIGRvZXMgbm90IG11dGF0ZS4gQ2FycmllcyBvdmVyIGFsbCBvdGhlciBMYXlvdXRJdGVtcyB1bm1vZGlmaWVkLlxuZnVuY3Rpb24gbW9kaWZ5TGF5b3V0KGxheW91dCAvKjogTGF5b3V0Ki8sIGxheW91dEl0ZW0gLyo6IExheW91dEl0ZW0qLykgLyo6IExheW91dCove1xuICBjb25zdCBuZXdMYXlvdXQgPSBBcnJheShsYXlvdXQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChsYXlvdXRJdGVtLmkgPT09IGxheW91dFtpXS5pKSB7XG4gICAgICBuZXdMYXlvdXRbaV0gPSBsYXlvdXRJdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXlvdXRbaV0gPSBsYXlvdXRbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdMYXlvdXQ7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byBtb2RpZnkgYSBsYXlvdXQgaXRlbS5cbi8vIERvZXMgZGVmZW5zaXZlIGNsb25lcyB0byBlbnN1cmUgdGhlIGxheW91dCBpcyBub3QgbW9kaWZpZWQuXG5mdW5jdGlvbiB3aXRoTGF5b3V0SXRlbShsYXlvdXQgLyo6IExheW91dCovLCBpdGVtS2V5IC8qOiBzdHJpbmcqLywgY2IgLyo6IExheW91dEl0ZW0gPT4gTGF5b3V0SXRlbSovKSAvKjogW0xheW91dCwgP0xheW91dEl0ZW1dKi97XG4gIGxldCBpdGVtID0gZ2V0TGF5b3V0SXRlbShsYXlvdXQsIGl0ZW1LZXkpO1xuICBpZiAoIWl0ZW0pIHJldHVybiBbbGF5b3V0LCBudWxsXTtcbiAgaXRlbSA9IGNiKGNsb25lTGF5b3V0SXRlbShpdGVtKSk7IC8vIGRlZmVuc2l2ZSBjbG9uZSB0aGVuIG1vZGlmeVxuICAvLyBGSVhNRSBjb3VsZCBkbyB0aGlzIGZhc3RlciBpZiB3ZSBhbHJlYWR5IGtuZXcgdGhlIGluZGV4XG4gIGxheW91dCA9IG1vZGlmeUxheW91dChsYXlvdXQsIGl0ZW0pO1xuICByZXR1cm4gW2xheW91dCwgaXRlbV07XG59XG5cbi8vIEZhc3QgcGF0aCB0byBjbG9uaW5nLCBzaW5jZSB0aGlzIGlzIG1vbm9tb3JwaGljXG5mdW5jdGlvbiBjbG9uZUxheW91dEl0ZW0obGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogTGF5b3V0SXRlbSove1xuICByZXR1cm4ge1xuICAgIHc6IGxheW91dEl0ZW0udyxcbiAgICBoOiBsYXlvdXRJdGVtLmgsXG4gICAgeDogbGF5b3V0SXRlbS54LFxuICAgIHk6IGxheW91dEl0ZW0ueSxcbiAgICBpOiBsYXlvdXRJdGVtLmksXG4gICAgbWluVzogbGF5b3V0SXRlbS5taW5XLFxuICAgIG1heFc6IGxheW91dEl0ZW0ubWF4VyxcbiAgICBtaW5IOiBsYXlvdXRJdGVtLm1pbkgsXG4gICAgbWF4SDogbGF5b3V0SXRlbS5tYXhILFxuICAgIG1vdmVkOiBCb29sZWFuKGxheW91dEl0ZW0ubW92ZWQpLFxuICAgIHN0YXRpYzogQm9vbGVhbihsYXlvdXRJdGVtLnN0YXRpYyksXG4gICAgLy8gVGhlc2UgY2FuIGJlIG51bGwvdW5kZWZpbmVkXG4gICAgaXNEcmFnZ2FibGU6IGxheW91dEl0ZW0uaXNEcmFnZ2FibGUsXG4gICAgaXNSZXNpemFibGU6IGxheW91dEl0ZW0uaXNSZXNpemFibGUsXG4gICAgcmVzaXplSGFuZGxlczogbGF5b3V0SXRlbS5yZXNpemVIYW5kbGVzLFxuICAgIGlzQm91bmRlZDogbGF5b3V0SXRlbS5pc0JvdW5kZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wYXJpbmcgUmVhY3QgYGNoaWxkcmVuYCBpcyBhIGJpdCBkaWZmaWN1bHQuIFRoaXMgaXMgYSBnb29kIHdheSB0byBjb21wYXJlIHRoZW0uXG4gKiBUaGlzIHdpbGwgY2F0Y2ggZGlmZmVyZW5jZXMgaW4ga2V5cywgb3JkZXIsIGFuZCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGNoaWxkcmVuRXF1YWwoYSAvKjogUmVhY3RDaGlsZHJlbiovLCBiIC8qOiBSZWFjdENoaWxkcmVuKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiAoMCwgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKShfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5tYXAoYSwgYyA9PiBjPy5rZXkpLCBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5tYXAoYiwgYyA9PiBjPy5rZXkpKSAmJiAoMCwgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKShfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5tYXAoYSwgYyA9PiBjPy5wcm9wc1tcImRhdGEtZ3JpZFwiXSksIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChiLCBjID0+IGM/LnByb3BzW1wiZGF0YS1ncmlkXCJdKSk7XG59XG5cbi8qKlxuICogU2VlIGBmYXN0UkdMUHJvcHNFcXVhbC5qc2AuXG4gKiBXZSB3YW50IHRoaXMgdG8gcnVuIGFzIGZhc3QgYXMgcG9zc2libGUgLSBpdCBpcyBjYWxsZWQgb2Z0ZW4gLSBhbmQgdG8gYmVcbiAqIHJlc2lsaWVudCB0byBuZXcgcHJvcHMgdGhhdCB3ZSBhZGQuIFNvIHJhdGhlciB0aGFuIGNhbGwgbG9kYXNoLmlzRXF1YWwsXG4gKiB3aGljaCBpc24ndCBzdWl0ZWQgdG8gY29tcGFyaW5nIHByb3BzIHZlcnkgd2VsbCwgd2UgdXNlIHRoaXMgc3BlY2lhbGl6ZWRcbiAqIGZ1bmN0aW9uIGluIGNvbmp1bmN0aW9uIHdpdGggcHJldmFsIHRvIGdlbmVyYXRlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIGNvbXBhcmlzb25cbiAqIGZ1bmN0aW9uLCB0dW5lZCBmb3IgZXhhY3RseSBvdXIgcHJvcHMuXG4gKi9cbi8qOjogdHlwZSBGYXN0UkdMUHJvcHNFcXVhbCA9IChPYmplY3QsIE9iamVjdCwgRnVuY3Rpb24pID0+IGJvb2xlYW47Ki9cbmNvbnN0IGZhc3RSR0xQcm9wc0VxdWFsIC8qOiBGYXN0UkdMUHJvcHNFcXVhbCovID0gZXhwb3J0cy5mYXN0UkdMUHJvcHNFcXVhbCA9IHJlcXVpcmUoXCIuL2Zhc3RSR0xQcm9wc0VxdWFsXCIpO1xuXG4vLyBMaWtlIHRoZSBhYm92ZSwgYnV0IGEgbG90IHNpbXBsZXIuXG5mdW5jdGlvbiBmYXN0UG9zaXRpb25FcXVhbChhIC8qOiBQb3NpdGlvbiovLCBiIC8qOiBQb3NpdGlvbiovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gYS5sZWZ0ID09PSBiLmxlZnQgJiYgYS50b3AgPT09IGIudG9wICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5oZWlnaHQgPT09IGIuaGVpZ2h0O1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byBsYXlvdXRpdGVtcywgY2hlY2sgaWYgdGhleSBjb2xsaWRlLlxuICovXG5mdW5jdGlvbiBjb2xsaWRlcyhsMSAvKjogTGF5b3V0SXRlbSovLCBsMiAvKjogTGF5b3V0SXRlbSovKSAvKjogYm9vbGVhbiove1xuICBpZiAobDEuaSA9PT0gbDIuaSkgcmV0dXJuIGZhbHNlOyAvLyBzYW1lIGVsZW1lbnRcbiAgaWYgKGwxLnggKyBsMS53IDw9IGwyLngpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgbGVmdCBvZiBsMlxuICBpZiAobDEueCA+PSBsMi54ICsgbDIudykgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyByaWdodCBvZiBsMlxuICBpZiAobDEueSArIGwxLmggPD0gbDIueSkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBhYm92ZSBsMlxuICBpZiAobDEueSA+PSBsMi55ICsgbDIuaCkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBiZWxvdyBsMlxuICByZXR1cm4gdHJ1ZTsgLy8gYm94ZXMgb3ZlcmxhcFxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGF5b3V0LCBjb21wYWN0IGl0LiBUaGlzIGludm9sdmVzIGdvaW5nIGRvd24gZWFjaCB5IGNvb3JkaW5hdGUgYW5kIHJlbW92aW5nIGdhcHNcbiAqIGJldHdlZW4gaXRlbXMuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IGxheW91dCBpdGVtcyAoY2xvbmVzKS4gQ3JlYXRlcyBhIG5ldyBsYXlvdXQgYXJyYXkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQuXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0XG4gKiAgIHZlcnRpY2FsbHkuXG4gKiBAcGFyYW0gIHtCb29sZWFufSBhbGxvd092ZXJsYXAgV2hlbiBgdHJ1ZWAsIGFsbG93cyBvdmVybGFwcGluZyBncmlkIGl0ZW1zLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgIENvbXBhY3RlZCBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3QobGF5b3V0IC8qOiBMYXlvdXQqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGNvbHMgLyo6IG51bWJlciovLCBhbGxvd092ZXJsYXAgLyo6ID9ib29sZWFuKi8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gU3RhdGljcyBnbyBpbiB0aGUgY29tcGFyZVdpdGggYXJyYXkgcmlnaHQgYXdheSBzbyBpdGVtcyBmbG93IGFyb3VuZCB0aGVtLlxuICBjb25zdCBjb21wYXJlV2l0aCA9IGdldFN0YXRpY3MobGF5b3V0KTtcbiAgLy8gV2UgZ28gdGhyb3VnaCB0aGUgaXRlbXMgYnkgcm93IGFuZCBjb2x1bW4uXG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQsIGNvbXBhY3RUeXBlKTtcbiAgLy8gSG9sZGluZyBmb3IgbmV3IGl0ZW1zLlxuICBjb25zdCBvdXQgPSBBcnJheShsYXlvdXQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBsID0gY2xvbmVMYXlvdXRJdGVtKHNvcnRlZFtpXSk7XG5cbiAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBlbGVtZW50c1xuICAgIGlmICghbC5zdGF0aWMpIHtcbiAgICAgIGwgPSBjb21wYWN0SXRlbShjb21wYXJlV2l0aCwgbCwgY29tcGFjdFR5cGUsIGNvbHMsIHNvcnRlZCwgYWxsb3dPdmVybGFwKTtcblxuICAgICAgLy8gQWRkIHRvIGNvbXBhcmlzb24gYXJyYXkuIFdlIG9ubHkgY29sbGlkZSB3aXRoIGl0ZW1zIGJlZm9yZSB0aGlzIG9uZS5cbiAgICAgIC8vIFN0YXRpY3MgYXJlIGFscmVhZHkgaW4gdGhpcyBhcnJheS5cbiAgICAgIGNvbXBhcmVXaXRoLnB1c2gobCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIG91dHB1dCBhcnJheSB0byBtYWtlIHN1cmUgdGhleSBzdGlsbCBjb21lIG91dCBpbiB0aGUgcmlnaHQgb3JkZXIuXG4gICAgb3V0W2xheW91dC5pbmRleE9mKHNvcnRlZFtpXSldID0gbDtcblxuICAgIC8vIENsZWFyIG1vdmVkIGZsYWcsIGlmIGl0IGV4aXN0cy5cbiAgICBsLm1vdmVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IGhlaWdodFdpZHRoID0ge1xuICB4OiBcIndcIixcbiAgeTogXCJoXCJcbn07XG4vKipcbiAqIEJlZm9yZSBtb3ZpbmcgaXRlbSBkb3duLCBpdCB3aWxsIGNoZWNrIGlmIHRoZSBtb3ZlbWVudCB3aWxsIGNhdXNlIGNvbGxpc2lvbnMgYW5kIG1vdmUgdGhvc2UgaXRlbXMgZG93biBiZWZvcmUuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGxheW91dCAvKjogTGF5b3V0Ki8sIGl0ZW0gLyo6IExheW91dEl0ZW0qLywgbW92ZVRvQ29vcmQgLyo6IG51bWJlciovLCBheGlzIC8qOiBcInhcIiB8IFwieVwiKi8pIHtcbiAgY29uc3Qgc2l6ZVByb3AgPSBoZWlnaHRXaWR0aFtheGlzXTtcbiAgaXRlbVtheGlzXSArPSAxO1xuICBjb25zdCBpdGVtSW5kZXggPSBsYXlvdXQubWFwKGxheW91dEl0ZW0gPT4ge1xuICAgIHJldHVybiBsYXlvdXRJdGVtLmk7XG4gIH0pLmluZGV4T2YoaXRlbS5pKTtcblxuICAvLyBHbyB0aHJvdWdoIGVhY2ggaXRlbSB3ZSBjb2xsaWRlIHdpdGguXG4gIGZvciAobGV0IGkgPSBpdGVtSW5kZXggKyAxOyBpIDwgbGF5b3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgb3RoZXJJdGVtID0gbGF5b3V0W2ldO1xuICAgIC8vIElnbm9yZSBzdGF0aWMgaXRlbXNcbiAgICBpZiAob3RoZXJJdGVtLnN0YXRpYykgY29udGludWU7XG5cbiAgICAvLyBPcHRpbWl6YXRpb246IHdlIGNhbiBicmVhayBlYXJseSBpZiB3ZSBrbm93IHdlJ3JlIHBhc3QgdGhpcyBlbFxuICAgIC8vIFdlIGNhbiBkbyB0aGlzIGIvYyBpdCdzIGEgc29ydGVkIGxheW91dFxuICAgIGlmIChvdGhlckl0ZW0ueSA+IGl0ZW0ueSArIGl0ZW0uaCkgYnJlYWs7XG4gICAgaWYgKGNvbGxpZGVzKGl0ZW0sIG90aGVySXRlbSkpIHtcbiAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGxheW91dCwgb3RoZXJJdGVtLCBtb3ZlVG9Db29yZCArIGl0ZW1bc2l6ZVByb3BdLCBheGlzKTtcbiAgICB9XG4gIH1cbiAgaXRlbVtheGlzXSA9IG1vdmVUb0Nvb3JkO1xufVxuXG4vKipcbiAqIENvbXBhY3QgYW4gaXRlbSBpbiB0aGUgbGF5b3V0LlxuICpcbiAqIE1vZGlmaWVzIGl0ZW0uXG4gKlxuICovXG5mdW5jdGlvbiBjb21wYWN0SXRlbShjb21wYXJlV2l0aCAvKjogTGF5b3V0Ki8sIGwgLyo6IExheW91dEl0ZW0qLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGNvbHMgLyo6IG51bWJlciovLCBmdWxsTGF5b3V0IC8qOiBMYXlvdXQqLywgYWxsb3dPdmVybGFwIC8qOiA/Ym9vbGVhbiovKSAvKjogTGF5b3V0SXRlbSove1xuICBjb25zdCBjb21wYWN0ViA9IGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCI7XG4gIGNvbnN0IGNvbXBhY3RIID0gY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiO1xuICBpZiAoY29tcGFjdFYpIHtcbiAgICAvLyBCb3R0b20gJ3knIHBvc3NpYmxlIGlzIHRoZSBib3R0b20gb2YgdGhlIGxheW91dC5cbiAgICAvLyBUaGlzIGFsbG93cyB5b3UgdG8gZG8gbmljZSBzdHVmZiBsaWtlIHNwZWNpZnkge3k6IEluZmluaXR5fVxuICAgIC8vIFRoaXMgaXMgaGVyZSBiZWNhdXNlIHRoZSBsYXlvdXQgbXVzdCBiZSBzb3J0ZWQgaW4gb3JkZXIgdG8gZ2V0IHRoZSBjb3JyZWN0IGJvdHRvbSBgeWAuXG4gICAgbC55ID0gTWF0aC5taW4oYm90dG9tKGNvbXBhcmVXaXRoKSwgbC55KTtcbiAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IHVwIGFzIGZhciBhcyBpdCBjYW4gZ28gd2l0aG91dCBjb2xsaWRpbmcuXG4gICAgd2hpbGUgKGwueSA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xuICAgICAgbC55LS07XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbXBhY3RIKSB7XG4gICAgLy8gTW92ZSB0aGUgZWxlbWVudCBsZWZ0IGFzIGZhciBhcyBpdCBjYW4gZ28gd2l0aG91dCBjb2xsaWRpbmcuXG4gICAgd2hpbGUgKGwueCA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xuICAgICAgbC54LS07XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZSBpdCBkb3duLCBhbmQga2VlcCBtb3ZpbmcgaXQgZG93biBpZiBpdCdzIGNvbGxpZGluZy5cbiAgbGV0IGNvbGxpZGVzO1xuICAvLyBDaGVja2luZyB0aGUgY29tcGFjdFR5cGUgbnVsbCB2YWx1ZSB0byBhdm9pZCBicmVha2luZyB0aGUgbGF5b3V0IHdoZW4gb3ZlcmxhcHBpbmcgaXMgYWxsb3dlZC5cbiAgd2hpbGUgKChjb2xsaWRlcyA9IGdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkgJiYgIShjb21wYWN0VHlwZSA9PT0gbnVsbCAmJiBhbGxvd092ZXJsYXApKSB7XG4gICAgaWYgKGNvbXBhY3RIKSB7XG4gICAgICByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihmdWxsTGF5b3V0LCBsLCBjb2xsaWRlcy54ICsgY29sbGlkZXMudywgXCJ4XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihmdWxsTGF5b3V0LCBsLCBjb2xsaWRlcy55ICsgY29sbGlkZXMuaCwgXCJ5XCIpO1xuICAgIH1cbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBncm93IHdpdGhvdXQgYm91bmRzIGhvcml6b250YWxseSwgaWYgd2UndmUgb3ZlcmZsb3duLCBsZXQncyBtb3ZlIGl0IGRvd24gYW5kIHRyeSBhZ2Fpbi5cbiAgICBpZiAoY29tcGFjdEggJiYgbC54ICsgbC53ID4gY29scykge1xuICAgICAgbC54ID0gY29scyAtIGwudztcbiAgICAgIGwueSsrO1xuICAgICAgLy8gQUxzbyBtb3ZlIGVsZW1lbnQgYXMgbGVmdCBhcyB3ZSBjYW5cbiAgICAgIHdoaWxlIChsLnggPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICAgICAgbC54LS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgYXJlIG5vIG5lZ2F0aXZlIHBvc2l0aW9uc1xuICBsLnkgPSBNYXRoLm1heChsLnksIDApO1xuICBsLnggPSBNYXRoLm1heChsLngsIDApO1xuICByZXR1cm4gbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxheW91dCwgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBmaXQgd2l0aGluIGl0cyBib3VuZHMuXG4gKlxuICogTW9kaWZpZXMgbGF5b3V0IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHBhcmFtICB7TnVtYmVyfSBib3VuZHMgTnVtYmVyIG9mIGNvbHVtbnMuXG4gKi9cbmZ1bmN0aW9uIGNvcnJlY3RCb3VuZHMobGF5b3V0IC8qOiBMYXlvdXQqLywgYm91bmRzIC8qOiB7IGNvbHM6IG51bWJlciB9Ki8pIC8qOiBMYXlvdXQqL3tcbiAgY29uc3QgY29sbGlkZXNXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgbCA9IGxheW91dFtpXTtcbiAgICAvLyBPdmVyZmxvd3MgcmlnaHRcbiAgICBpZiAobC54ICsgbC53ID4gYm91bmRzLmNvbHMpIGwueCA9IGJvdW5kcy5jb2xzIC0gbC53O1xuICAgIC8vIE92ZXJmbG93cyBsZWZ0XG4gICAgaWYgKGwueCA8IDApIHtcbiAgICAgIGwueCA9IDA7XG4gICAgICBsLncgPSBib3VuZHMuY29scztcbiAgICB9XG4gICAgaWYgKCFsLnN0YXRpYykgY29sbGlkZXNXaXRoLnB1c2gobCk7ZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIHN0YXRpYyBhbmQgY29sbGlkZXMgd2l0aCBvdGhlciBzdGF0aWNzLCB3ZSBtdXN0IG1vdmUgaXQgZG93bi5cbiAgICAgIC8vIFdlIGhhdmUgdG8gZG8gc29tZXRoaW5nIG5pY2VyIHRoYW4ganVzdCBsZXR0aW5nIHRoZW0gb3ZlcmxhcC5cbiAgICAgIHdoaWxlIChnZXRGaXJzdENvbGxpc2lvbihjb2xsaWRlc1dpdGgsIGwpKSB7XG4gICAgICAgIGwueSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGF5b3V0O1xufVxuXG4vKipcbiAqIEdldCBhIGxheW91dCBpdGVtIGJ5IElELiBVc2VkIHNvIHdlIGNhbiBvdmVycmlkZSBsYXRlciBvbiBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgSURcbiAqIEByZXR1cm4ge0xheW91dEl0ZW19ICAgIEl0ZW0gYXQgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldExheW91dEl0ZW0obGF5b3V0IC8qOiBMYXlvdXQqLywgaWQgLyo6IHN0cmluZyovKSAvKjogP0xheW91dEl0ZW0qL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChsYXlvdXRbaV0uaSA9PT0gaWQpIHJldHVybiBsYXlvdXRbaV07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHRoaXMgbGF5b3V0IGNvbGxpZGVzIHdpdGguXG4gKiBJdCBkb2Vzbid0IGFwcGVhciB0byBtYXR0ZXIgd2hpY2ggb3JkZXIgd2UgYXBwcm9hY2ggdGhpcyBmcm9tLCBhbHRob3VnaFxuICogcGVyaGFwcyB0aGF0IGlzIHRoZSB3cm9uZyB0aGluZyB0byBkby5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGxheW91dEl0ZW0gTGF5b3V0IGl0ZW0uXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAgQSBjb2xsaWRpbmcgbGF5b3V0IGl0ZW0sIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0IC8qOiBMYXlvdXQqLywgbGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogP0xheW91dEl0ZW0qL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjb2xsaWRlcyhsYXlvdXRbaV0sIGxheW91dEl0ZW0pKSByZXR1cm4gbGF5b3V0W2ldO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBbGxDb2xsaXNpb25zKGxheW91dCAvKjogTGF5b3V0Ki8sIGxheW91dEl0ZW0gLyo6IExheW91dEl0ZW0qLykgLyo6IEFycmF5PExheW91dEl0ZW0+Ki97XG4gIHJldHVybiBsYXlvdXQuZmlsdGVyKGwgPT4gY29sbGlkZXMobCwgbGF5b3V0SXRlbSkpO1xufVxuXG4vKipcbiAqIEdldCBhbGwgc3RhdGljIGVsZW1lbnRzLlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgQXJyYXkgb2Ygc3RhdGljIGxheW91dCBpdGVtcy4uXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY3MobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IEFycmF5PExheW91dEl0ZW0+Ki97XG4gIHJldHVybiBsYXlvdXQuZmlsdGVyKGwgPT4gbC5zdGF0aWMpO1xufVxuXG4vKipcbiAqIE1vdmUgYW4gZWxlbWVudC4gUmVzcG9uc2libGUgZm9yIGRvaW5nIGNhc2NhZGluZyBtb3ZlbWVudHMgb2Ygb3RoZXIgZWxlbWVudHMuXG4gKlxuICogTW9kaWZpZXMgbGF5b3V0IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGwgICAgICAgICAgICAgICAgIGVsZW1lbnQgdG8gbW92ZS5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt4XSAgICAgICAgICAgICAgIFggcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt5XSAgICAgICAgICAgICAgIFkgcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnQobGF5b3V0IC8qOiBMYXlvdXQqLywgbCAvKjogTGF5b3V0SXRlbSovLCB4IC8qOiA/bnVtYmVyKi8sIHkgLyo6ID9udW1iZXIqLywgaXNVc2VyQWN0aW9uIC8qOiA/Ym9vbGVhbiovLCBwcmV2ZW50Q29sbGlzaW9uIC8qOiA/Ym9vbGVhbiovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dCove1xuICAvLyBJZiB0aGlzIGlzIHN0YXRpYyBhbmQgbm90IGV4cGxpY2l0bHkgZW5hYmxlZCBhcyBkcmFnZ2FibGUsXG4gIC8vIG5vIG1vdmUgaXMgcG9zc2libGUsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0IHRoaXMgaW1tZWRpYXRlbHkuXG4gIGlmIChsLnN0YXRpYyAmJiBsLmlzRHJhZ2dhYmxlICE9PSB0cnVlKSByZXR1cm4gbGF5b3V0O1xuXG4gIC8vIFNob3J0LWNpcmN1aXQgaWYgbm90aGluZyB0byBkby5cbiAgaWYgKGwueSA9PT0geSAmJiBsLnggPT09IHgpIHJldHVybiBsYXlvdXQ7XG4gIGxvZyhgTW92aW5nIGVsZW1lbnQgJHtsLml9IHRvIFske1N0cmluZyh4KX0sJHtTdHJpbmcoeSl9XSBmcm9tIFske2wueH0sJHtsLnl9XWApO1xuICBjb25zdCBvbGRYID0gbC54O1xuICBjb25zdCBvbGRZID0gbC55O1xuXG4gIC8vIFRoaXMgaXMgcXVpdGUgYSBiaXQgZmFzdGVyIHRoYW4gZXh0ZW5kaW5nIHRoZSBvYmplY3RcbiAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSBsLnggPSB4O1xuICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIGwueSA9IHk7XG4gIGwubW92ZWQgPSB0cnVlO1xuXG4gIC8vIElmIHRoaXMgY29sbGlkZXMgd2l0aCBhbnl0aGluZywgbW92ZSBpdC5cbiAgLy8gV2hlbiBkb2luZyB0aGlzIGNvbXBhcmlzb24sIHdlIGhhdmUgdG8gc29ydCB0aGUgaXRlbXMgd2UgY29tcGFyZSB3aXRoXG4gIC8vIHRvIGVuc3VyZSwgaW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgY29sbGlzaW9ucywgdGhhdCB3ZSdyZSBnZXR0aW5nIHRoZVxuICAvLyBuZWFyZXN0IGNvbGxpc2lvbi5cbiAgbGV0IHNvcnRlZCA9IHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQsIGNvbXBhY3RUeXBlKTtcbiAgY29uc3QgbW92aW5nVXAgPSBjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiICYmIHR5cGVvZiB5ID09PSBcIm51bWJlclwiID8gb2xkWSA+PSB5IDogY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiICYmIHR5cGVvZiB4ID09PSBcIm51bWJlclwiID8gb2xkWCA+PSB4IDogZmFsc2U7XG4gIC8vICRGbG93SWdub3JlIGFjY2VwdGFibGUgbW9kaWZpY2F0aW9uIG9mIHJlYWQtb25seSBhcnJheSBhcyBpdCB3YXMgcmVjZW50bHkgY2xvbmVkXG4gIGlmIChtb3ZpbmdVcCkgc29ydGVkID0gc29ydGVkLnJldmVyc2UoKTtcbiAgY29uc3QgY29sbGlzaW9ucyA9IGdldEFsbENvbGxpc2lvbnMoc29ydGVkLCBsKTtcbiAgY29uc3QgaGFzQ29sbGlzaW9ucyA9IGNvbGxpc2lvbnMubGVuZ3RoID4gMDtcblxuICAvLyBXZSBtYXkgaGF2ZSBjb2xsaXNpb25zLiBXZSBjYW4gc2hvcnQtY2lyY3VpdCBpZiB3ZSd2ZSB0dXJuZWQgb2ZmIGNvbGxpc2lvbnMgb3JcbiAgLy8gYWxsb3dlZCBvdmVybGFwLlxuICBpZiAoaGFzQ29sbGlzaW9ucyAmJiBhbGxvd092ZXJsYXApIHtcbiAgICAvLyBFYXN5LCB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgY29sbGlzaW9ucy4gQnV0IHdlICpkaWQqIGNoYW5nZSB0aGUgbGF5b3V0LFxuICAgIC8vIHNvIGNsb25lIGl0IG9uIHRoZSB3YXkgb3V0LlxuICAgIHJldHVybiBjbG9uZUxheW91dChsYXlvdXQpO1xuICB9IGVsc2UgaWYgKGhhc0NvbGxpc2lvbnMgJiYgcHJldmVudENvbGxpc2lvbikge1xuICAgIC8vIElmIHdlIGFyZSBwcmV2ZW50aW5nIGNvbGxpc2lvbiBidXQgbm90IGFsbG93aW5nIG92ZXJsYXAsIHdlIG5lZWQgdG9cbiAgICAvLyByZXZlcnQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBzbyBpdCBnb2VzIHRvIHdoZXJlIGl0IGNhbWUgZnJvbSwgcmF0aGVyXG4gICAgLy8gdGhhbiB0aGUgdXNlcidzIGRlc2lyZWQgbG9jYXRpb24uXG4gICAgbG9nKGBDb2xsaXNpb24gcHJldmVudGVkIG9uICR7bC5pfSwgcmV2ZXJ0aW5nLmApO1xuICAgIGwueCA9IG9sZFg7XG4gICAgbC55ID0gb2xkWTtcbiAgICBsLm1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGxheW91dDsgLy8gZGlkIG5vdCBjaGFuZ2Ugc28gZG9uJ3QgY2xvbmVcbiAgfVxuXG4gIC8vIE1vdmUgZWFjaCBpdGVtIHRoYXQgY29sbGlkZXMgYXdheSBmcm9tIHRoaXMgZWxlbWVudC5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvbGxpc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xuICAgIGxvZyhgUmVzb2x2aW5nIGNvbGxpc2lvbiBiZXR3ZWVuICR7bC5pfSBhdCBbJHtsLnh9LCR7bC55fV0gYW5kICR7Y29sbGlzaW9uLml9IGF0IFske2NvbGxpc2lvbi54fSwke2NvbGxpc2lvbi55fV1gKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgc28gd2UgY2FuJ3QgaW5maW5pdGUgbG9vcFxuICAgIGlmIChjb2xsaXNpb24ubW92ZWQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRG9uJ3QgbW92ZSBzdGF0aWMgaXRlbXMgLSB3ZSBoYXZlIHRvIG1vdmUgKnRoaXMqIGVsZW1lbnQgYXdheVxuICAgIGlmIChjb2xsaXNpb24uc3RhdGljKSB7XG4gICAgICBsYXlvdXQgPSBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dCwgY29sbGlzaW9uLCBsLCBpc1VzZXJBY3Rpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQsIGwsIGNvbGxpc2lvbiwgaXNVc2VyQWN0aW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qKlxuICogVGhpcyBpcyB3aGVyZSB0aGUgbWFnaWMgbmVlZHMgdG8gaGFwcGVuIC0gZ2l2ZW4gYSBjb2xsaXNpb24sIG1vdmUgYW4gZWxlbWVudCBhd2F5IGZyb20gdGhlIGNvbGxpc2lvbi5cbiAqIFdlIGF0dGVtcHQgdG8gbW92ZSBpdCB1cCBpZiB0aGVyZSdzIHJvb20sIG90aGVyd2lzZSBpdCBnb2VzIGJlbG93LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgICAgICAgICAgICBGdWxsIGxheW91dCB0byBtb2RpZnkuXG4gKiBAcGFyYW0gIHtMYXlvdXRJdGVtfSBjb2xsaWRlc1dpdGggTGF5b3V0IGl0ZW0gd2UncmUgY29sbGlkaW5nIHdpdGguXG4gKiBAcGFyYW0gIHtMYXlvdXRJdGVtfSBpdGVtVG9Nb3ZlICAgTGF5b3V0IGl0ZW0gd2UncmUgbW92aW5nLlxuICovXG5mdW5jdGlvbiBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dCAvKjogTGF5b3V0Ki8sIGNvbGxpZGVzV2l0aCAvKjogTGF5b3V0SXRlbSovLCBpdGVtVG9Nb3ZlIC8qOiBMYXlvdXRJdGVtKi8sIGlzVXNlckFjdGlvbiAvKjogP2Jvb2xlYW4qLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGNvbHMgLyo6IG51bWJlciovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IGNvbXBhY3RIID0gY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiO1xuICAvLyBDb21wYWN0IHZlcnRpY2FsbHkgaWYgbm90IHNldCB0byBob3Jpem9udGFsXG4gIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIjtcbiAgY29uc3QgcHJldmVudENvbGxpc2lvbiA9IGNvbGxpZGVzV2l0aC5zdGF0aWM7IC8vIHdlJ3JlIGFscmVhZHkgY29sbGlkaW5nIChub3QgZm9yIHN0YXRpYyBpdGVtcylcblxuICAvLyBJZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgYWJvdmUgdGhlIGNvbGxpc2lvbiB0byBwdXQgdGhpcyBlbGVtZW50LCBtb3ZlIGl0IHRoZXJlLlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gdGhlIG1haW4gY29sbGlzaW9uIGFzIHRoaXMgY2FuIGdldCBmdW5reSBpbiBjYXNjYWRlcyBhbmQgY2F1c2VcbiAgLy8gdW53YW50ZWQgc3dhcHBpbmcgYmVoYXZpb3IuXG4gIGlmIChpc1VzZXJBY3Rpb24pIHtcbiAgICAvLyBSZXNldCBpc1VzZXJBY3Rpb24gZmxhZyBiZWNhdXNlIHdlJ3JlIG5vdCBpbiB0aGUgbWFpbiBjb2xsaXNpb24gYW55bW9yZS5cbiAgICBpc1VzZXJBY3Rpb24gPSBmYWxzZTtcblxuICAgIC8vIE1ha2UgYSBtb2NrIGl0ZW0gc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBpdGVtIGhlcmUsIG9ubHkgbW9kaWZ5IGluIG1vdmVFbGVtZW50LlxuICAgIGNvbnN0IGZha2VJdGVtIC8qOiBMYXlvdXRJdGVtKi8gPSB7XG4gICAgICB4OiBjb21wYWN0SCA/IE1hdGgubWF4KGNvbGxpZGVzV2l0aC54IC0gaXRlbVRvTW92ZS53LCAwKSA6IGl0ZW1Ub01vdmUueCxcbiAgICAgIHk6IGNvbXBhY3RWID8gTWF0aC5tYXgoY29sbGlkZXNXaXRoLnkgLSBpdGVtVG9Nb3ZlLmgsIDApIDogaXRlbVRvTW92ZS55LFxuICAgICAgdzogaXRlbVRvTW92ZS53LFxuICAgICAgaDogaXRlbVRvTW92ZS5oLFxuICAgICAgaTogXCItMVwiXG4gICAgfTtcbiAgICBjb25zdCBmaXJzdENvbGxpc2lvbiA9IGdldEZpcnN0Q29sbGlzaW9uKGxheW91dCwgZmFrZUl0ZW0pO1xuICAgIGNvbnN0IGNvbGxpc2lvbk5vcnRoID0gZmlyc3RDb2xsaXNpb24gJiYgZmlyc3RDb2xsaXNpb24ueSArIGZpcnN0Q29sbGlzaW9uLmggPiBjb2xsaWRlc1dpdGgueTtcbiAgICBjb25zdCBjb2xsaXNpb25XZXN0ID0gZmlyc3RDb2xsaXNpb24gJiYgY29sbGlkZXNXaXRoLnggKyBjb2xsaWRlc1dpdGgudyA+IGZpcnN0Q29sbGlzaW9uLng7XG5cbiAgICAvLyBObyBjb2xsaXNpb24/IElmIHNvLCB3ZSBjYW4gZ28gdXAgdGhlcmU7IG90aGVyd2lzZSwgd2UnbGwgZW5kIHVwIG1vdmluZyBkb3duIGFzIG5vcm1hbFxuICAgIGlmICghZmlyc3RDb2xsaXNpb24pIHtcbiAgICAgIGxvZyhgRG9pbmcgcmV2ZXJzZSBjb2xsaXNpb24gb24gJHtpdGVtVG9Nb3ZlLml9IHVwIHRvIFske2Zha2VJdGVtLnh9LCR7ZmFrZUl0ZW0ueX1dLmApO1xuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgaXRlbVRvTW92ZSwgY29tcGFjdEggPyBmYWtlSXRlbS54IDogdW5kZWZpbmVkLCBjb21wYWN0ViA/IGZha2VJdGVtLnkgOiB1bmRlZmluZWQsIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uTm9ydGggJiYgY29tcGFjdFYpIHtcbiAgICAgIHJldHVybiBtb3ZlRWxlbWVudChsYXlvdXQsIGl0ZW1Ub01vdmUsIHVuZGVmaW5lZCwgY29sbGlkZXNXaXRoLnkgKyAxLCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9IGVsc2UgaWYgKGNvbGxpc2lvbk5vcnRoICYmIGNvbXBhY3RUeXBlID09IG51bGwpIHtcbiAgICAgIGNvbGxpZGVzV2l0aC55ID0gaXRlbVRvTW92ZS55O1xuICAgICAgaXRlbVRvTW92ZS55ID0gaXRlbVRvTW92ZS55ICsgaXRlbVRvTW92ZS5oO1xuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9IGVsc2UgaWYgKGNvbGxpc2lvbldlc3QgJiYgY29tcGFjdEgpIHtcbiAgICAgIHJldHVybiBtb3ZlRWxlbWVudChsYXlvdXQsIGNvbGxpZGVzV2l0aCwgaXRlbVRvTW92ZS54LCB1bmRlZmluZWQsIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXdYID0gY29tcGFjdEggPyBpdGVtVG9Nb3ZlLnggKyAxIDogdW5kZWZpbmVkO1xuICBjb25zdCBuZXdZID0gY29tcGFjdFYgPyBpdGVtVG9Nb3ZlLnkgKyAxIDogdW5kZWZpbmVkO1xuICBpZiAobmV3WCA9PSBudWxsICYmIG5ld1kgPT0gbnVsbCkge1xuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cbiAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgaXRlbVRvTW92ZSwgY29tcGFjdEggPyBpdGVtVG9Nb3ZlLnggKyAxIDogdW5kZWZpbmVkLCBjb21wYWN0ViA/IGl0ZW1Ub01vdmUueSArIDEgOiB1bmRlZmluZWQsIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgcGVyY2VudGFnZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBudW0gQW55IG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfSAgICAgVGhhdCBudW1iZXIgYXMgYSBwZXJjZW50YWdlLlxuICovXG5mdW5jdGlvbiBwZXJjKG51bSAvKjogbnVtYmVyKi8pIC8qOiBzdHJpbmcqL3tcbiAgcmV0dXJuIG51bSAqIDEwMCArIFwiJVwiO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdG8gY29uc3RyYWluIGRpbWVuc2lvbnMgb2YgYSBHcmlkSXRlbVxuICovXG5jb25zdCBjb25zdHJhaW5XaWR0aCA9IChsZWZ0IC8qOiBudW1iZXIqLywgY3VycmVudFdpZHRoIC8qOiBudW1iZXIqLywgbmV3V2lkdGggLyo6IG51bWJlciovLCBjb250YWluZXJXaWR0aCAvKjogbnVtYmVyKi8pID0+IHtcbiAgcmV0dXJuIGxlZnQgKyBuZXdXaWR0aCA+IGNvbnRhaW5lcldpZHRoID8gY3VycmVudFdpZHRoIDogbmV3V2lkdGg7XG59O1xuY29uc3QgY29uc3RyYWluSGVpZ2h0ID0gKHRvcCAvKjogbnVtYmVyKi8sIGN1cnJlbnRIZWlnaHQgLyo6IG51bWJlciovLCBuZXdIZWlnaHQgLyo6IG51bWJlciovKSA9PiB7XG4gIHJldHVybiB0b3AgPCAwID8gY3VycmVudEhlaWdodCA6IG5ld0hlaWdodDtcbn07XG5jb25zdCBjb25zdHJhaW5MZWZ0ID0gKGxlZnQgLyo6IG51bWJlciovKSA9PiBNYXRoLm1heCgwLCBsZWZ0KTtcbmNvbnN0IGNvbnN0cmFpblRvcCA9ICh0b3AgLyo6IG51bWJlciovKSA9PiBNYXRoLm1heCgwLCB0b3ApO1xuY29uc3QgcmVzaXplTm9ydGggPSAoY3VycmVudFNpemUsIF9yZWYsIF9jb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIGxlZnQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmO1xuICBjb25zdCB0b3AgPSBjdXJyZW50U2l6ZS50b3AgLSAoaGVpZ2h0IC0gY3VycmVudFNpemUuaGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodDogY29uc3RyYWluSGVpZ2h0KHRvcCwgY3VycmVudFNpemUuaGVpZ2h0LCBoZWlnaHQpLFxuICAgIHRvcDogY29uc3RyYWluVG9wKHRvcClcbiAgfTtcbn07XG5jb25zdCByZXNpemVFYXN0ID0gKGN1cnJlbnRTaXplLCBfcmVmMiwgY29udGFpbmVyV2lkdGgpID0+IHtcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGg6IGNvbnN0cmFpbldpZHRoKGN1cnJlbnRTaXplLmxlZnQsIGN1cnJlbnRTaXplLndpZHRoLCB3aWR0aCwgY29udGFpbmVyV2lkdGgpLFxuICAgIGxlZnQ6IGNvbnN0cmFpbkxlZnQobGVmdClcbiAgfTtcbn07XG5jb25zdCByZXNpemVXZXN0ID0gKGN1cnJlbnRTaXplLCBfcmVmMywgY29udGFpbmVyV2lkdGgpID0+IHtcbiAgbGV0IHtcbiAgICB0b3AsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmMztcbiAgY29uc3QgbGVmdCA9IGN1cnJlbnRTaXplLmxlZnQgLSAod2lkdGggLSBjdXJyZW50U2l6ZS53aWR0aCk7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoOiBsZWZ0IDwgMCA/IGN1cnJlbnRTaXplLndpZHRoIDogY29uc3RyYWluV2lkdGgoY3VycmVudFNpemUubGVmdCwgY3VycmVudFNpemUud2lkdGgsIHdpZHRoLCBjb250YWluZXJXaWR0aCksXG4gICAgdG9wOiBjb25zdHJhaW5Ub3AodG9wKSxcbiAgICBsZWZ0OiBjb25zdHJhaW5MZWZ0KGxlZnQpXG4gIH07XG59O1xuY29uc3QgcmVzaXplU291dGggPSAoY3VycmVudFNpemUsIF9yZWY0LCBjb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgbGVmdCxcbiAgICBoZWlnaHQ6IGNvbnN0cmFpbkhlaWdodCh0b3AsIGN1cnJlbnRTaXplLmhlaWdodCwgaGVpZ2h0KSxcbiAgICB0b3A6IGNvbnN0cmFpblRvcCh0b3ApXG4gIH07XG59O1xuY29uc3QgcmVzaXplTm9ydGhFYXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzaXplTm9ydGgoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCByZXNpemVFYXN0KC4uLmFyZ3VtZW50cyksIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG59O1xuY29uc3QgcmVzaXplTm9ydGhXZXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzaXplTm9ydGgoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCByZXNpemVXZXN0KC4uLmFyZ3VtZW50cyksIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG59O1xuY29uc3QgcmVzaXplU291dGhFYXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzaXplU291dGgoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCByZXNpemVFYXN0KC4uLmFyZ3VtZW50cyksIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG59O1xuY29uc3QgcmVzaXplU291dGhXZXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzaXplU291dGgoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCByZXNpemVXZXN0KC4uLmFyZ3VtZW50cyksIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG59O1xuY29uc3Qgb3JkaW5hbFJlc2l6ZUhhbmRsZXJNYXAgPSB7XG4gIG46IHJlc2l6ZU5vcnRoLFxuICBuZTogcmVzaXplTm9ydGhFYXN0LFxuICBlOiByZXNpemVFYXN0LFxuICBzZTogcmVzaXplU291dGhFYXN0LFxuICBzOiByZXNpemVTb3V0aCxcbiAgc3c6IHJlc2l6ZVNvdXRoV2VzdCxcbiAgdzogcmVzaXplV2VzdCxcbiAgbnc6IHJlc2l6ZU5vcnRoV2VzdFxufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNsYW1waW5nIHdpZHRoIGFuZCBwb3NpdGlvbiB3aGVuIHJlc2l6aW5nIGFuIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZUl0ZW1JbkRpcmVjdGlvbihkaXJlY3Rpb24gLyo6IFJlc2l6ZUhhbmRsZUF4aXMqLywgY3VycmVudFNpemUgLyo6IFBvc2l0aW9uKi8sIG5ld1NpemUgLyo6IFBvc2l0aW9uKi8sIGNvbnRhaW5lcldpZHRoIC8qOiBudW1iZXIqLykgLyo6IFBvc2l0aW9uKi97XG4gIGNvbnN0IG9yZGluYWxIYW5kbGVyID0gb3JkaW5hbFJlc2l6ZUhhbmRsZXJNYXBbZGlyZWN0aW9uXTtcbiAgLy8gU2hvdWxkbid0IGJlIHBvc3NpYmxlIGdpdmVuIHR5cGVzOyB0aGF0IHNhaWQsIGRvbid0IGZhaWwgaGFyZFxuICBpZiAoIW9yZGluYWxIYW5kbGVyKSByZXR1cm4gbmV3U2l6ZTtcbiAgcmV0dXJuIG9yZGluYWxIYW5kbGVyKGN1cnJlbnRTaXplLCB7XG4gICAgLi4uY3VycmVudFNpemUsXG4gICAgLi4ubmV3U2l6ZVxuICB9LCBjb250YWluZXJXaWR0aCk7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oX3JlZjUgLyo6OiAqLykgLyo6IE9iamVjdCove1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9IC8qOiBQb3NpdGlvbiovID0gX3JlZjUgLyo6IFBvc2l0aW9uKi87XG4gIC8vIFJlcGxhY2UgdW5pdGxlc3MgaXRlbXMgd2l0aCBweFxuICBjb25zdCB0cmFuc2xhdGUgPSBgdHJhbnNsYXRlKCR7bGVmdH1weCwke3RvcH1weClgO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIE1velRyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIG1zVHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgT1RyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldFRvcExlZnQoX3JlZjYgLyo6OiAqLykgLyo6IE9iamVjdCove1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9IC8qOiBQb3NpdGlvbiovID0gX3JlZjYgLyo6IFBvc2l0aW9uKi87XG4gIHJldHVybiB7XG4gICAgdG9wOiBgJHt0b3B9cHhgLFxuICAgIGxlZnQ6IGAke2xlZnR9cHhgLFxuICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgbGF5b3V0IGl0ZW1zIHNvcnRlZCBmcm9tIHRvcCBsZWZ0IHRvIHJpZ2h0IGFuZCBkb3duLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgTGF5b3V0LCBzb3J0ZWQgc3RhdGljIGl0ZW1zIGZpcnN0LlxuICovXG5mdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXMobGF5b3V0IC8qOiBMYXlvdXQqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8pIC8qOiBMYXlvdXQqL3tcbiAgaWYgKGNvbXBhY3RUeXBlID09PSBcImhvcml6b250YWxcIikgcmV0dXJuIHNvcnRMYXlvdXRJdGVtc0J5Q29sUm93KGxheW91dCk7XG4gIGlmIChjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiKSByZXR1cm4gc29ydExheW91dEl0ZW1zQnlSb3dDb2wobGF5b3V0KTtlbHNlIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qKlxuICogU29ydCBsYXlvdXQgaXRlbXMgYnkgcm93IGFzY2VuZGluZyBhbmQgY29sdW1uIGFzY2VuZGluZy5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgTGF5b3V0LlxuICovXG5mdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQgLyo6IExheW91dCovKSAvKjogTGF5b3V0Ki97XG4gIC8vIFNsaWNlIHRvIGNsb25lIGFycmF5IGFzIHNvcnQgbW9kaWZpZXNcbiAgcmV0dXJuIGxheW91dC5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEueSA+IGIueSB8fCBhLnkgPT09IGIueSAmJiBhLnggPiBiLngpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYS55ID09PSBiLnkgJiYgYS54ID09PSBiLngpIHtcbiAgICAgIC8vIFdpdGhvdXQgdGhpcywgd2UgY2FuIGdldCBkaWZmZXJlbnQgc29ydCByZXN1bHRzIGluIElFIHZzLiBDaHJvbWUvRkZcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNvcnQgbGF5b3V0IGl0ZW1zIGJ5IGNvbHVtbiBhc2NlbmRpbmcgdGhlbiByb3cgYXNjZW5kaW5nLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtc0J5Q29sUm93KGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBMYXlvdXQqL3tcbiAgcmV0dXJuIGxheW91dC5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEueCA+IGIueCB8fCBhLnggPT09IGIueCAmJiBhLnkgPiBiLnkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbGF5b3V0IHVzaW5nIHRoZSBpbml0aWFsTGF5b3V0IGFuZCBjaGlsZHJlbiBhcyBhIHRlbXBsYXRlLlxuICogTWlzc2luZyBlbnRyaWVzIHdpbGwgYmUgYWRkZWQsIGV4dHJhbmVvdXMgb25lcyB3aWxsIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgaW5pdGlhbExheW91dC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIGluaXRpYWxMYXlvdXQgTGF5b3V0IHBhc3NlZCBpbiB0aHJvdWdoIHByb3BzLlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgIEN1cnJlbnQgcmVzcG9uc2l2ZSBicmVha3BvaW50LlxuICogQHBhcmFtICB7P1N0cmluZ30gY29tcGFjdCAgICAgIENvbXBhY3Rpb24gb3B0aW9uLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgIFdvcmtpbmcgbGF5b3V0LlxuICovXG5mdW5jdGlvbiBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbihpbml0aWFsTGF5b3V0IC8qOiBMYXlvdXQqLywgY2hpbGRyZW4gLyo6IFJlYWN0Q2hpbGRyZW4qLywgY29scyAvKjogbnVtYmVyKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBhbGxvd092ZXJsYXAgLyo6ID9ib29sZWFuKi8pIC8qOiBMYXlvdXQqL3tcbiAgaW5pdGlhbExheW91dCA9IGluaXRpYWxMYXlvdXQgfHwgW107XG5cbiAgLy8gR2VuZXJhdGUgb25lIGxheW91dCBpdGVtIHBlciBjaGlsZC5cbiAgY29uc3QgbGF5b3V0IC8qOiBMYXlvdXRJdGVtW10qLyA9IFtdO1xuICBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki8pID0+IHtcbiAgICAvLyBDaGlsZCBtYXkgbm90IGV4aXN0XG4gICAgaWYgKGNoaWxkPy5rZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0cyA9IGdldExheW91dEl0ZW0oaW5pdGlhbExheW91dCwgU3RyaW5nKGNoaWxkLmtleSkpO1xuICAgIGNvbnN0IGcgPSBjaGlsZC5wcm9wc1tcImRhdGEtZ3JpZFwiXTtcbiAgICAvLyBEb24ndCBvdmVyd3JpdGUgdGhlIGxheW91dCBpdGVtIGlmIGl0J3MgYWxyZWFkeSBpbiB0aGUgaW5pdGlhbCBsYXlvdXQuXG4gICAgLy8gSWYgaXQgaGFzIGEgYGRhdGEtZ3JpZGAgcHJvcGVydHksIHByZWZlciB0aGF0IG92ZXIgd2hhdCdzIGluIHRoZSBsYXlvdXQuXG4gICAgaWYgKGV4aXN0cyAmJiBnID09IG51bGwpIHtcbiAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbShleGlzdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGV5LCB0aGlzIGl0ZW0gaGFzIGEgZGF0YS1ncmlkIHByb3BlcnR5LCB1c2UgaXQuXG4gICAgICBpZiAoZykge1xuICAgICAgICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgICAgICAgIHZhbGlkYXRlTGF5b3V0KFtnXSwgXCJSZWFjdEdyaWRMYXlvdXQuY2hpbGRyZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRklYTUUgY2xvbmUgbm90IHJlYWxseSBuZWNlc3NhcnkgaGVyZVxuICAgICAgICBsYXlvdXQucHVzaChjbG9uZUxheW91dEl0ZW0oe1xuICAgICAgICAgIC4uLmcsXG4gICAgICAgICAgaTogY2hpbGQua2V5XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdGhpbmcgcHJvdmlkZWQ6IGVuc3VyZSB0aGlzIGlzIGFkZGVkIHRvIHRoZSBib3R0b21cbiAgICAgICAgLy8gRklYTUUgY2xvbmUgbm90IHJlYWxseSBuZWNlc3NhcnkgaGVyZVxuICAgICAgICBsYXlvdXQucHVzaChjbG9uZUxheW91dEl0ZW0oe1xuICAgICAgICAgIHc6IDEsXG4gICAgICAgICAgaDogMSxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IGJvdHRvbShsYXlvdXQpLFxuICAgICAgICAgIGk6IFN0cmluZyhjaGlsZC5rZXkpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIENvcnJlY3QgdGhlIGxheW91dC5cbiAgY29uc3QgY29ycmVjdGVkTGF5b3V0ID0gY29ycmVjdEJvdW5kcyhsYXlvdXQsIHtcbiAgICBjb2xzOiBjb2xzXG4gIH0pO1xuICByZXR1cm4gYWxsb3dPdmVybGFwID8gY29ycmVjdGVkTGF5b3V0IDogY29tcGFjdChjb3JyZWN0ZWRMYXlvdXQsIGNvbXBhY3RUeXBlLCBjb2xzKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIGxheW91dC4gVGhyb3dzIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxheW91dCAgICAgICAgQXJyYXkgb2YgbGF5b3V0IGl0ZW1zLlxuICogQHBhcmFtICB7U3RyaW5nfSBbY29udGV4dE5hbWVdIENvbnRleHQgbmFtZSBmb3IgZXJyb3JzLlxuICogQHRocm93ICB7RXJyb3J9ICAgICAgICAgICAgICAgIFZhbGlkYXRpb24gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0KGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiB2b2lkKi97XG4gIGxldCBjb250ZXh0TmFtZSAvKjogc3RyaW5nKi8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiTGF5b3V0XCI7XG4gIGNvbnN0IHN1YlByb3BzID0gW1wieFwiLCBcInlcIiwgXCJ3XCIsIFwiaFwiXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxheW91dCkpIHRocm93IG5ldyBFcnJvcihjb250ZXh0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXkhXCIpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGxheW91dFtpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN1YlByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBrZXkgPSBzdWJQcm9wc1tqXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCBOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVhY3RHcmlkTGF5b3V0OiAke2NvbnRleHROYW1lfVske2l9XS4ke2tleX0gbXVzdCBiZSBhIG51bWJlciEgUmVjZWl2ZWQ6ICR7dmFsdWV9ICgke3R5cGVvZiB2YWx1ZX0pYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaXRlbS5pICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBpdGVtLmkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVhY3RHcmlkTGF5b3V0OiAke2NvbnRleHROYW1lfVske2l9XS5pIG11c3QgYmUgYSBzdHJpbmchIFJlY2VpdmVkOiAke2l0ZW0uaX0gKCR7dHlwZW9mIGl0ZW0uaX0pYCk7XG4gICAgfVxuICB9XG59XG5cbi8vIExlZ2FjeSBzdXBwb3J0IGZvciB2ZXJ0aWNhbENvbXBhY3Q6IGZhbHNlXG5mdW5jdGlvbiBjb21wYWN0VHlwZShwcm9wcyAvKjogP3sgdmVydGljYWxDb21wYWN0OiBib29sZWFuLCBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUgfSovKSAvKjogQ29tcGFjdFR5cGUqL3tcbiAgY29uc3Qge1xuICAgIHZlcnRpY2FsQ29tcGFjdCxcbiAgICBjb21wYWN0VHlwZVxuICB9ID0gcHJvcHMgfHwge307XG4gIHJldHVybiB2ZXJ0aWNhbENvbXBhY3QgPT09IGZhbHNlID8gbnVsbCA6IGNvbXBhY3RUeXBlO1xufVxuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAoIURFQlVHKSByZXR1cm47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG59XG5jb25zdCBub29wID0gKCkgPT4ge307XG5leHBvcnRzLm5vb3AgPSBub29wOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-grid-layout/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\")[\"default\"];\nmodule.exports.utils = __webpack_require__(/*! ./build/utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nmodule.exports.calculateUtils = __webpack_require__(/*! ./build/calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nmodule.exports.Responsive = __webpack_require__(/*! ./build/ResponsiveReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\")[\"default\"];\nmodule.exports.Responsive.utils = __webpack_require__(/*! ./build/responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nmodule.exports.WidthProvider = __webpack_require__(/*! ./build/components/WidthProvider */ \"(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUpBQTJEO0FBQzNELHdIQUErQztBQUMvQyxtSkFBaUU7QUFDakUsZ0xBQ3NEO0FBQ3RELHVKQUFvRTtBQUNwRSxpTEFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2luZGV4LmpzP2ExMmYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9idWlsZC9SZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLnV0aWxzID0gcmVxdWlyZShcIi4vYnVpbGQvdXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5jYWxjdWxhdGVVdGlscyA9IHJlcXVpcmUoXCIuL2J1aWxkL2NhbGN1bGF0ZVV0aWxzXCIpO1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2l2ZSA9XG4gIHJlcXVpcmUoXCIuL2J1aWxkL1Jlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNpdmUudXRpbHMgPSByZXF1aXJlKFwiLi9idWlsZC9yZXNwb25zaXZlVXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5XaWR0aFByb3ZpZGVyID1cbiAgcmVxdWlyZShcIi4vYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyXCIpLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/css/styles.css":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-layout/css/styles.css ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c6cf8de1bab5\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvY3NzL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVtaXVtLWJlbnRvLWdyaWQtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2Nzcy9zdHlsZXMuY3NzP2NmOWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJjNmNmOGRlMWJhYjVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/css/styles.css\n");

/***/ })

};
;